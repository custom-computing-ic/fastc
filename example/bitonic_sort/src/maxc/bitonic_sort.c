#include "strategy.c"
// MaxC Example for Bitonic Sort

// design parameters that can be varied using the design space
// exploration aspect in Step 1 to generate the available configurations
const int n = 128;

// create a bitonic sort network
void FPGASort(int **inputs, int **outputs) {
  int** outNext, **in, **out;
  for (int size = 2; size <=n; size*=2) {
    for (int start = 0; start < n; start += size) {

      bool sortAsc = (start / size) % 2 == 0;
      for (int i = 0; i < size; i++) in[i]  = inputs[i];

      for (int mergeSize = size; mergeSize >= n; size /= 2) {
        for (int mergeStart = 0; mergeStart < size; mergeStart += mergeSize) {

          int mid = size / 2;
          for (int i = mergeStart; i < mergeStart + mid; i++) {
            bool swap = (sortAsc ? *in[i] > *in[mid + i] : *in[i] < *in[mid + i]);
            out[i] = swap ? in[mid + i] : in [i];
            out[mid + i] = swap ? in[i] : in[mid + i];
          }
        }
        in = out;
      }

      for (int i = 0; i < size; i++) outNext[start + i] = out[i];
    }
    inArray = outNext;
  }
  outputs = inArray;
}

static int compare(const void *p1, const void *p2) {
  int result = (*(int *)p1) - (*(int *)p2);
  return (result > 0 ? 1 : (result < 0 ? -1 : 0));
}

void sort(int n, int arrayWidth, int wordLength, int* input, int* array) {
  memcpy(result, array, n * wordLength);
  for (int i = 0; i < n; i += arrayWidth)
    // comparator function should be chosen based on type
    qsort(exp + i, arrayWidth, wordLength, compare);
}

int main(int argc, char** argv) {

  int n, arrayWidth, type, wordLength, exponent;
  void **input, **result;
  read_input(&n, &arrayWidth, &type, &wordLength, &exponent, input);

# pragma maxc adaptivereconf when:n > 2^17 and:arrayWidth[8..32]
  sort(n, arrayWidth, wordLength, array, result);

  print_result(n, arrayWidth, result);
}

// the results of applying the adaptive reconfiguration aspect
// on the original main function
int main_expected(int argc, char **argv) {

  int n, arrayWidth, type, wordLength, exponent;
  void **input, **result;
  read_input(&n, &arrayWidth, &type, &wordLength, &exponent, input);

  requiredDesign = design(arrayWidth, type);
  loadDesign     = getLoadedDesign();

  // mapping the required inputs to the existing configurations
  // will be generated by the adaptive reconfiguration aspect
  if ( haveFPGADesign(n, arrayWidth, wordLength)  &&
       increasesPerformance(arrayWidth, n, requiredDesign, loadedDesign)) {
    // 1. if FPGA design exists and performance is better figure out
    // if we need to and if it is more efficient to reconfigure to a
    // different network or just run the existing desing with added
    // padding

    if ( !compatible(requiredDesign, loadedDesign) ||
         estimatedPaddingTime(arrayWidth, n) +
         estimatedExecutionTime(arrayWidth, n, loadedDesign.wordLength) >
         estimatedReconfigurationTime() +
         estimatedExecutionTime(arrayWidth, n, requiredWordLength)) {
      // 1.1 Load a new configuration and run it
      if (type == INT ) {
        if (wordLength == 32) {
          if (arrayWidth == 128) {
            if ( n > 2^17 ) {
# pragma maxc hw:FPGASort cfg: bitonic_sort_int32_128
              sort(n, arrayWidth, array, result);
            }
          } else if {...}
        } else if {...}
      } else if (type == FLOAT) {
        if (wordLength ==32) {
          if (exponent == 8) {
            if (arrayWidth == 64) {
              if (n > 2^17) {
# pragma maxc hw:FPGASort cfg: bitonic_sort_float824_64
                sort(n, arrayWidth, array, result);
              }
            } else if {....}
          } else if {....}
        } else if {...}
      } else {
        sort(n, arrayWidth, array, result);
      }
    } else {
      // 1.2 pad the data to match the existing network word length
      // and size and run the currently loaded configuration
      pad(array, wordLength, arrayWidth);
# pragma maxc hw:FPGASort
      sort(n, arrayWidth, array, result);
    }
  } else {
      // 2. run the CPU version
      sort(n, arrayWidth, array, result);
  }

  print_result(n, arrayWidth, result);
}
