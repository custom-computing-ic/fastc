package MyApp_pkg;

import com.maxeler.maxcompiler.v1.managers.FPGAManager;
import com.maxeler.maxcompiler.v1.statemachine.SMStateEnum;
import com.maxeler.maxcompiler.v1.statemachine.SMStateValue;
import com.maxeler.maxcompiler.v1.statemachine.manager.ManagerStateMachine;
import com.maxeler.maxcompiler.v1.statemachine.manager.SMPullInput;
import com.maxeler.maxcompiler.v1.statemachine.manager.SMPushOutput;


public final class SMOutput extends ManagerStateMachine {
	// types
	private enum Mode  {Start, Output0, Output1, Output2}

	// inputs/outputs
	private final SMPullInput iInput0;
	private final SMPullInput iInput1;
	private final SMPullInput iInput2;
	private final SMPushOutput oOutput;

	// state
	private final SMStateValue sReadDataReady;
	private final SMStateValue sCounter;
	private final SMStateEnum<Mode> sMode;

	// constructor
	public SMOutput(FPGAManager owner) {
		super(owner);

		// Initialize state
		sCounter    = state.value(smUInt(8), 0);
		sMode = state.enumerated(Mode.class, Mode.Start);

		sReadDataReady = state.value(smBool(), false);

		// Set up inputs/outputs
    // Stream width allign with memory width
		iInput0  = io.pullInput("input0",    smUInt(1536));
		iInput1  = io.pullInput("input1",    smUInt(1536));
		iInput2  = io.pullInput("input2",    smUInt(1536));
		oOutput  = io.pushOutput("output",   smUInt(1536), 1);
	}

	@Override
	protected void nextState() {

		/*
		 * We only get data from the input if:
		 *  - the input was not empty in the previous cycle
		 *  AND
		 *  - the output was not stalled in the previous cycle
		 */
    sReadDataReady.next <== ~iInput0.empty & ~iInput1.empty &~oOutput.stall;

		/*
		 * If we get data from the input, then we can count 0s
		 * or 1s and decode the data stream */
		IF (sReadDataReady.eq(true)) {
      SWITCH(sMode) {
        CASE (Mode.Start) {
          IF (sCounter.eq(10)){
            sCounter.next <== 0;
            sMode.next    <== Mode.Output0;
          }
          ELSE {
            sCounter.next <== sCounter + 1;
  			  sMode.next    <== Mode.Start;
  				}
        }
        //Distribute data to data-path 0 
        //Switch to next data-path after two cycles
        CASE (Mode.Output0) {
					IF (sCounter.eq(0)){
            sCounter.next <== sCounter + 1;
					  sMode.next    <== Mode.Output0;
          }
          ELSE {
            sCounter.next <== 0;
            sMode.next    <== Mode.Output1;
						}
					}
        //Distribute data to data-path 1
        //Switch to next data-path after two cycles
        CASE (Mode.Output1) {
					IF (sCounter.eq(0)){
						sCounter.next <== sCounter + 1;
					  sMode.next    <== Mode.Output1;
          }
          ELSE {
            sCounter.next <== 0;
            sMode.next    <== Mode.Output2;
						}
					}
        //Distribute data to data-path 1
        //Switch to next data-path after two cycles
        CASE (Mode.Output2) {
					IF (sCounter.eq(0)){
						sCounter.next <== sCounter + 1;
					  sMode.next    <== Mode.Output2;
          }
          ELSE {
            sCounter.next <== 0;
            sMode.next    <== Mode.Output0;
						}
					}
			  }
		  }
    //debug part
    //debug.printf("SM:   Cycle:%d Status:%d sReadDataReady:%d\n" ,sCounter, sMode, sReadDataReady);
    }

	@Override
	protected void outputFunction() {
		/*
		 * We only request data from the input if:
		 *  - the input is not empty
		 *  AND
		 *  - the output is not stalled
		 */

		iInput0.read <== (~iInput0.empty & ~iInput1.empty & ~oOutput.stall &~sMode.eq(Mode.Start)) 
                    |(sMode.eq(Mode.Start) & sCounter.eq(10)) ;
		
    iInput1.read <== (~iInput0.empty & ~iInput1.empty & ~oOutput.stall &~sMode.eq(Mode.Start)) 
                    |(sMode.eq(Mode.Start) & sCounter.eq(10)) ;

		//Dynamically output inputs, if they are valid
      SWITCH(sMode) {
        //Distribute data, switch to next data-path after two cycles
        CASE (Mode.Output0) {
        oOutput <== iInput0;
        oOutput.valid <==sReadDataReady;
        }
        //Distribute data, switch to next data-path after two cycles
        CASE (Mode.Output1) {
        oOutput <== iInput1;
        oOutput.valid <==sReadDataReady;
			  }
        //Distribute data, switch to next data-path after two cycles
        CASE (Mode.Output2) {
        oOutput <== iInput2;
        oOutput.valid <==sReadDataReady;
			  }
    }
    //debug part
    //debug.printf("InputRequest:%d\niInput:%d \noOutput0:%d, \noOutput1:%d\n", iInput.read, iInput, oOutput0, oOutput1);

  }
}

