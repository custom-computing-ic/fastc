\section{Evaluation}

\subsection{RTM Implementation}
We evaluate the proposed approach by implementing a high-performance
application based on the Reverse Time Migration method for seismic
imaging which is used to detect geological structures, based on the
Earth's response to injected acoustic waves. The technique models the
propagation of injected waves using the isotropic acoustic wave
equation \cite{araya2011assessing}:
\begin{align}
\frac{d^2p(r,t)}{dt^2} + {dvv(r)}^2\bigtriangledown^2p(r,t) = f(r,t)
\end{align}
We approximate the differential equation using stencil computation to
perform a fifth-order Taylor expansion in space and first-order Taylor
expansion in time.

We use MaxC to implement the dataflow kernels and aspects to generate
multiple configurations for the design by creating two kernels that
are used to control the memory command read and write streams
(CmdRead, CmdWrite) and the computation kernel (RTM).  To illustrate
the potential benefits of our approach we analyse the results of using
the \texttt{DebugValues} aspect described in Section
\ref{sec:dbg-aspect}.  Table \ref{table:loc} compares the number of
lines of code required for the original MaxC + Aspect implementation
with the equivalent MaxJ implementation showing a reduction in code
size of 56\% for the run-time reconfigurable design and a reduction in
the number of API calls (including debug calls) of 33\% which
translate into increase productivity.

\begin{table}[!h]
  \renewcommand{\arraystretch}{1.3}
  \centering
  \caption{Code measures for the RTM kernels comparing MaxC and
    MaxJ.}
  \label{table:loc}
  \begin{tabular}{c|ccc|cc}
    \hline
    \multirow{2}{*}{\bf{Kernel}} & \bf{Aspect } & \multicolumn{2}{c|}{\bf{MaxC}} & \multicolumn{2}{c}{\bf{MaxJ}}                   \\
    \                            & \bf{LOC}     & \bf{LOC}                       & \bf{\# API calls} & \bf{LOC} & \bf{\#API Calls} \\
    \hline \hline
    CmdRead                      & 12           & 26                             &      6         & 59       &      39        \\
    CmdWrite                     & 12           & 28                             &      39        & 79      &       56         \\
    RTM Static                   & 12           & 246                            &     43         & 403     &       175        \\
    RTM RTR                      & 12           & 377                            &     91         & 669     &       275       \\
  \end{tabular}
\end{table}


\subsection{Results}

Results of the design space exploration using the word length aspect
illustrate the trade-offs between accuracy and resource usage (Fig.~\ref{fig:precision}). We observe irregular, large variations when
decreasing the mantissa from 18 to 16 and 24 to 22. These non-linear
differences are counter-intuitive, halving the number of required DSPs
with little relative impact on accuracy. This is the effect of the
backend tools mapping arithmetic to a combination of both DSPs and
LUT/FF elements. The mantissa boundaries at which this optimization
occurs are platform specific, depending on the architecture of the
DSPs. Hence automating this optimization via aspects and decoupling it
from the original source code makes the application more portable and
facilitates discovery of interesting trade-off opportunities using
design space exploration.

\begin{figure}[!h]
\includegraphics[scale=0.7]{figs/pre}
\caption{Exploration of accuracy vs resource usage trade-offs using the aspect 
shown in Fig.~\ref{fig:aspect-exploration} with variable mantissa.}
\label{fig:precision}
\end{figure}

\begin{comment}
\begin{table}[!h]
  %  \renewcommand{\arraystretch}{1.1}
  \centering
  \caption{Results of varying the word length.}
  \label{table:aspect-wl}
  \begin{tabular}{ p{1cm} p{1cm} p{1cm} p{1cm} p{1cm}  p{1cm} }
    Word Width & LUT               & FF                & BRAM           & DSP             & Relative Error \\ \hline
    8, 24      & 106033  (35.63\%) & 143508  (24.11\%) & 295  (27.73\%) & 702  (34.82\%)  & \TODO          \\
    8, 22      & 133973  (45.02\%) & 185520  (31.17\%) & 295  (27.73\%) & 306  (15.18\%)  & \TODO          \\
    8, 20      & 129581  (43.54\%) & 178333  (29.96\%) & 289  (27.16\%) & 306  (15.18\%)  & \TODO          \\
    8, 18      & 121439  (40.81\%) & 170721  (28.68\%) & 286  (26.88\%) & 306  (15.18\%)  & \TODO          \\
    8, 16      & 117904  (39.62\%) & 157359  (26.44\%) & 283  (26.60\%) & 204  (10.12\%)  & \TODO          \\
  \end{tabular}
\end{table}
\end{comment}


The DSP aspect allows to explore the resource trade-offs of
implementing arithmetic operations in either DSPs or LUTs and FFs
(Fig.~\ref{fig:arith}). This helps to avoid over mapping on DSPs for
arithmetic intensive applications.

\begin{figure}[!h]
\includegraphics[scale=0.7]{figs/arith}
\caption{Exploration of DSP and LUT/FF balancing for arithmetic
  operations using the aspect showin in Fig.~\ref{fig:aspect-DSP}.}
\label{fig:arith}
\end{figure}

Design space exploration using the parallelism aspect can be used to
investigate design scalability. For example for the described RTM
implementation, Fig.~\ref{fig:scalability} shows that performance
scales linearly with the number of parallel pipelines. This also shows
that significant speedups can be obtained by the MaxC dataflow design
compared to the CPU only implementation. Depending on the problem
size, our approach can be used to achieve a significant speedup over
software only versions which is comparable with the best published
FPGA results for static designs
\cite{Xinyu:Qiwei:Luk:Qiang:Pell:2012}, \cite{araya2011assessing}.

\pgfplotsset{every axis x label/.style={
  at={(0.5,0)},
  below,
  yshift=-5pt}}

\pgfplotsset{every axis y label/.style={
  at={(0,0.5)},
  xshift=-20pt,
  rotate=90}}

\begin{figure}[!h]
  \centering
  \begin{tikzpicture}
    \selectcolormodel{gray}
    \begin{axis}[
        xmin=1,
        ymin=1,
        %no markers,
        font=\tiny,
        xlabel=Pipes,
        ylabel=Speedup,
        xtick={1,2,3,6,12},
        ytick={4, 10, 20, 40, 50, 70, 80, 100},
        legend columns=2,
        legend entries={
          Static (S),
          RTR (S),
          Static (M),
          RTR (M),
          Static (L),
          RTR (L)},
        legend style={
          draw=none,
          at={(0.05,0.85) },
          anchor=west
        }
      ]

      \addplot[mark=none] coordinates {
        (1, 3.2)
        (2, 6.53)
        (3, 9.8)
        (6, 19.6)
        (12, 39.2)
      };
      \addplot[mark=*] coordinates {
        (1, 6.75)
        (2, 13.5)
        (3, 20.25)
        (6, 40.5)
        (12, 81)
      };
      \addplot[dotted] coordinates {
        (1, 3.13)
        (2, 6.26)
        (3, 9.4)
        (6, 18.8)
        (12, 37.6)
      };
      \addplot[mark=*, dotted] coordinates {
        (1, 4.75)
        (2, 9.51)
        (3, 14.27)
        (6, 28.5)
        (12, 57.1)
      };
      \addplot[mark=none, dashed] coordinates {
        (1, 8.5)
        (2, 17.13)
        (3, 25.7)
        (6, 51.4)
        (12, 102.8)
      };
      \addplot[mark=*, dashed] coordinates {
        (1, 4.25)
        (2, 8.48)
        (3, 12.725)
        (6, 25.42)
        (12, 50.9)
      };2
    \end{axis}
  \end{tikzpicture}
  \caption{Scalability of the RTM dataflow design explored using the aspect 
shown in Fig.~\ref{fig:aspect-exploration}.}
  \label{fig:scalability}
\end{figure}

Fig.~\ref{fig:scalability} also shows the performance benefits of
using a run-time reconfiguration implementation. This is generated by
using the reconfiguration aspect to create two configurations for the
RTM MaxC kernel. Since during the first half of the execution the
backward propagation and imaging functions are idle, the first
configuration requires only half the resources. This allows doubling
the number of parallel pipelines and halves the execution time of the
first configuration. The speedup obtained is comparable to
\cite{Xinyu:Qiwei:Luk:Qiang:Pell:2012}, but the partitioning and
optimization exploration process is automated via aspects, which
increases developer productivity. The automated process improves
portability of the design, allowing optimisations based on design
space exploration to be carried out on various platforms (hence
subject to varying resource constraints) without manual intervention.
