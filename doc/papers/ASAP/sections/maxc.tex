\section{The \MAXC{} Language}
\label{sec:maxc}

\MAXC{} (Facile Aspect-driven Source Transformation) is a novel
language for specifying dataflow designs that are used as a starting
point for the design flow proposed in Section
\ref{sec:design-flow}. In particular, we use C syntax to capture
dataflow computations, and, instead of heavily relying on API libraries
to specify the design (as in MaxCompiler \cite{5719584} or Streams-C
\cite{Gokhale:Stone:Arnold:Kalinowski:2000}), we use aspects to
implement the transformations required for the actual implementation.

\MAXC{} provides the following features that are
required by the proposed flow:

\begin{itemize}
\item \emph{Imperative specification of dataflow designs}. C99 syntax is
  enforced by the \MAXC{} compiler which is based on the ROSE
  Framework (with EDG as a front-end) and makes the language familiar
  and easy to adopt for developers, facilitating translation of
  existing application code to dataflow designs.
\item \emph{Good integration with existing source level translation and
  weaving tools}. Simple syntax allows the language to interact well
  with existing compilers or source to source translation frameworks,
  allowing source level optimisations to be applied through different
  tools.
\item \emph{Combined hardware/software design}. Specifications of dataflow
  kernels and CPU run-time software can be mixed. The example shown in
  Fig.~\ref{fig:maxc-1dconv} can be compiled with the GCC toolchain,
  but when using the \MAXC{} compiler, the pragma indicates the link
  between the software and hardware, which results in an accelerated
  hardware software/solution.
\item \emph{Support for data path and control path generation}. \MAXC{}
  allows specifying both data and control operations that are
  automatically mapped to stream multiplexers.
\end{itemize}

\MAXC{} is used to express the simplest form of a dataflow design
while optimisations and other transformations are encapsulated in
aspects which are developed separately and applied through aspect
weaving. This results in a flexible approach for generating and
exploring the space of efficient dataflow designs.

Designs in \MAXC{} are compiled to MaxCompiler designs composed of
inter-connected functional kernels. Communication between kernels is
asynchronous, so they can operate independently, and compute only when
all active inputs have available data.

Table~\ref{table:maxc-features} summarises the features of \MAXC{} and
Fig.~\ref{fig:maxc-1dconv} shows an example dataflow kernel used to
value European options. Kernels are defined as regular C functions
with inputs clearly defined as arguments in the function
signature. Streams are represented as regular C99-style pointers.
Normal array notation can be used to generate either previous or
future values or dereference the stream to obtain the current stream
value. Negative indices are allowed for accessing previous stream
values and supported offset expressions are linear expressions
comprised of constants or variables (either loop induction variables,
or normal variables but for which a compile time range of values is
specified -- this is required to generate efficient
hardware). Constructs such as loops are supported as long as their
bounds are known at compile time and are used to parametrize dataflow
designs with values known at compilation time.

\begin{table}[!h]
  \centering
\renewcommand{\arraystretch}{1.6}
\caption{Summary of the main features of the \MAXC{} language.}
\label{table:maxc-features}
\begin{tabular}{p{1.7cm}|l|l}
\hline
\bf{Feature}                   & \bf{Description}                   & \bf{Method (see Fig.~\ref{fig:maxc-1dconv})} \\
\hline\hline
  \multirow{2}{*}{Input/Output}         & Declared in function header          & C99 (line 1)                                 \\\cline{2-3}       & \texttt{in()},\texttt{out()}  & \MAXC{} API (lines 2,11) \\
\hline
  \multirow{2}{*}{Control}     & Ternary op., \texttt{if} statement & C99 (line 11)                                \\\cline{2-3}      & Stream mux (\texttt{mux()})       & \MAXC{} API  \\
\hline
\multirow{2}{*}{Computation} & +, *, /, -                         & C99 (line 8)                           \\\cline{2-3} & log, exp, sqrt, sin etc.  & \#include $<$math.h$>$  \\
\hline
  \multirow{2}{*}{Streams}     & Declared as pointers               & C99 (line 1)                                 \\\cline{2-3}       & Accessed with array index & C99 (line 8) \\
\hline
  Optimisation                 & C pragmas                   & C99 (line 7)                                 \\
\hline
  Parameterization             & Constants, variables                   & C99                                          \\
\hline
Hardware \  Mapping                  & C pragmas                   & C99 (line 17)                                \\
\end{tabular}
\end{table}



\lstset{style=MaxC}

\begin{figure}[!h]
  \begin{lstlisting}
    void Price_FPGA(float* p, float c_0_0_0, float c_p_0_0, float c_n_0_0, int n1, int ORDER) {
      in(p);

      float* i4 = count(1000, 1);
      float* i1 = countChain(n1, 1, i4);

      #pragma FAST DSPBalance:full
      int result = p[0]  * c_0_0_0 + p[1]  * c_p_0_0 + p[-1] * c_n_0_0;

      int up =(i1 >= ORDER) && (i1 < n1 - ORDER);
      out(up ? result : p);
    }

    void Price_CPU(...) {...}

    int main() {
      #pragma FAST hw:Price_FPGA
      Price_CPU(...);
    }
  \end{lstlisting}
  \caption{\MAXC{} dataflow kernel for European Options
    pricing.}
  \label{fig:maxc-1dconv}
\end{figure}


The \MAXC{} API provides higher-level constructs such as I/O functions
(\texttt{in()}, \texttt{out()}), counters (Fig.~\ref{fig:maxc-1dconv},
Lines 4--5) and functions to multiplex streams (\texttt{mux()}). C
function calls are mapped to dataflow kernels via pragmas (Line 17)
which provides the flexibility of selecting a particular dataflow
configuration based on run-time conditions. Support for run-time
reconfiguration is included but will be described in a future
publication due to lack of space.
