\section{The  MaxC Language}

MaxC is a novel language for specifying dataflow designs. It is based
on the widely used C99 standard which makes it familiar and easy to
adopt for developers facilitating translation of existing application
code to dataflow designs. The simple syntax of C99 facilitates
integration with other tools (such as aspect weavers), allowing the
language to interact well with existing compilers or source to source
translation frameworks (e.g. LARA, ROSE), allowing source level
optimizations to be applied through different tools. MaxC itself is a
simple language, which is intended to be used for expressing the
simplest form of a dataflow design. Optimizations and other
transformations are encapsulated in aspects which are developed
separately and applied through aspect weaving. This results in a more
flexible approach for generating and exploring the space of efficient
dataflow designs.

\begin{comment}
  We identify the following requirements for any dataflow language:
  \begin{enumerate}
  \item intuitive and easy to use
  \item facilitate translation of existing applications
  \item interacts well with
    high-level tools
  \end{enumerate}
\end{comment}

Since MaxC is compiled to MaxJ it uses the same execution model: a
design is composed of one or more computational kernels (which
implement the functionality we are interested in) which are connected
to form a design. Communication between kernels is asynchronous, so
kernels can operate independently of each other but computation within
kernels is synchronous, so a kernel will compute only when all it's
active inputs have values available.

Figure \ref{fig:maxc-1dconv} shows an example MaxC dataflow kernel
which implements a 1D convolution computation used to value European
options.


\lstset{style=MaxC}

\begin{figure}
  \begin{lstlisting}
    void kernel_Convolution1D(float* p, float c_0_0_0, float c_p_0_0, float c_n_0_0, int n1, int ORDER, float* out)
    {

      in(p);

      float* i4 = count(1000, 1);
      float* i1 = countChain(n1, 1, i4);

      #pragma maxc DSPBalance:full
      int result =
        p[0]  * c_0_0_0 +
        p[1]  * c_p_0_0 +
        p[-1] * c_n_0_0;

      int up =(i1 >= ORDER) && (i1 < n1 - ORDER);

      out = up ? result : p;

      out(out);
    }
  \end{lstlisting}
  \caption{Example MaxC design for a 1D convolution kernel.}
  \label{fig:maxc-1dconv}
\end{figure}

\subsection{Kernels}

Kernels are defined as regular C functions, with the ``kernel\_''
identifier prepended (Line 1). The inputs and outputs of the kernel
are clearly specified in the header, inputs followed by outputs. At
the kernel level MaxC captures the dataflow elements by using:

\begin{itemize}
\item \emph{regular C constructs} are used as much as possible to make
  the language more intuitive. This includes standard C99 types and
  conventions for implementing kernels. Some overloaded operators are
  provided such as the array access operators to provide a more
  succinct syntax for accessing ``past'' or ``future'' stream elements
  (Lines 15 -- 17).

\item \emph{pragma directives} are used to convey additional
  information to the compiler for which C99 does not provide flexible
  built-in constructs (e.g. specifying type width) or additional
  optimization hints (e.g. the DSP balance, Line 13);

\item \emph{specific API calls} are used for higher level constructs
  such as inputs and outputs (Lines 8, 24), counters (Lines 10 -- 11).

\end{itemize}


Figure \ref{fig:maxc-1dconv} shows the main elements of a MaxC design:

\begin{enumerate}
\item \emph{inputs and outputs} are declared in the kernel header and
  connected in the kernel body. Lines 2-6 show the kernel declaration
  specifying the stream input "p" and output "out" as well as a number
  of scalar parameters configurable at run-time. API calls are used to
  connect these inputs (Line 7 and 22);

\item \emph{control} elements are implemented either via standard C99
  constructs (such as conditional statements or operators) or via API
  calls that enable multiplexing between 2 or more streams;

\item \emph{computation} is implemented using regular C99 syntax and
  semantics. The MaxCC backend will also automatically translate
  standard functions in the C99 math library to hardware blocks for
  common functions such as square root, exponential, logarithms.

\item \emph{streams} are represented as regular C99 pointers. For
  example Line 2 declares a stream of float values names ``p''.
  Normal array notation can be used to generate either previous
  (negative indices) or future values (positive indices) or
  dereference the stream to get the current stream value. Negative
  indices are allowed (as on Line 16). On lines 13-16 we use array
  index notation to access future (positive offset) or past (negative
  offset) stream elements. Supported offset expressions are linear
  expressions comprised of constants or variables (either loop
  induction variables, or normal variables but for which a compile
  time range of values is specified -- this is required to generate
  efficient hardware).

\item \emph{compile time constructs} such as loops are supported as
  long as their bounds are known at compile time.

\item \emph{optimizations} can be applied via pragmas (Line 12) or API
  calls. Additional type information can also be provided via pragmas.

\end{enumerate}

The MaxC API provides a number of useful, higher-level constructs.
such as output functions that are used to connect an internal kernel
stream to the output stream of a kernel, various counters and counter
chain configurations that can be instantiated using functions from the
counter API (Lines 9 -- 10) or functions such as stream\_select that
are used to multiplex between a number of streams based on the value
of condition stream.


\begin{comment}
\subsection{Designs}

MaxC also allows specification of designs using multiple kernels. This
involves selecting the kernel instances and connecting them as well as
setting a number of design configuration and compilation options such
as operating frequency.

Figure \ref{lst:maxc-design} illustrates the design for the 1D
convolution example which places and connects memory command kernels
to control the generation of memory streams and the actual computation
kernels.

On Lines 3-6 we specify the kernel instances. On Lines 8 -- 10 we
connect these. Lines 13 -- 15 specify the design frequency, the memory
clock frequency and enable the addition of debug elements.

\begin{figure}[!h]
  \centering
  \begin{lstlisting}
    void design_Convolution1D() {
      // kernels
      kernel_t k1 = kernel_init(kernel_Convolution1D);
      kernel_t k2 = kernel_init(kernel_Cmdwrite);
      kernel_t k3 = kernel_init(kernel_Cmdread);

      // connections
      connect2(k1, k2);
      connect3(k1, k2, ``a'');
      connect4(k1, k3, ``a'', ``b'');

      // configuration
      set_frequency(150);
      set_memory_frequency(333);
      set_enable_debug(true);
    }
  \end{lstlisting}
  \caption{MaxC design specification, connecting multiple kernels and
    setting various configuration options}
  \label{lst:maxc-design}
\end{figure}
\end{comment}
