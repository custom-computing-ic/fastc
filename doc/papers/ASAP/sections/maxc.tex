\section{The \MAXC{} Language}
\label{sec:maxc}

\MAXC{} (Facile Aspect-driven Source Transformation) is a novel
language for specifying dataflow designs that are used as a starting
point for the design proposed in Section \ref{sec:design-flow}. In
particular, we use the C language as an intermediate language to
capture the dataflow computation, and instead of heavily relying on
API libraries to specify the design (as in MaxCompiler
\cite{MaxelerTechnologies:2012} or Streams-C
\cite{Gokhale:Stone:Arnold:Kalinowski:2000}) we use aspects to
implement the transformations required for the actual implementation.

\MAXC{} provides the following features that are
required by the proposed flow:

\begin{itemize}
\item Imperative specification of dataflow designs. The C99 syntax
  makes it familiar and easy to adopt for developers, facilitating
  translation of existing application code to dataflow designs.
\item Good interaction with existing source level translation and
  weaving tools. Simple syntax allows the language to interact well
  with existing compilers or source to source translation frameworks,
  allowing source level optimisations to be applied through different
  tools.
\item Combined hardware/software design. Specifications of dataflow
  kernels and CPU run-time software can be mixed. The example shown in
  Fig.~\ref{fig:maxc-1dconv} can be compiled with the GCC toolchain
  without any issues, but when using the \MAXC{} compiler, the pragma
  indicates the link between the software and hardware, which results
  in an accelerated hardware software/solution.
\item Supports datapath and control path generation. \MAXC{} allows
  specifying both datapath and control operations that are
  automatically mapped to stream multiplexers.
\end{itemize}

\MAXC{} is designed to express the simplest form of a dataflow design
while optimisations and other transformations are encapsulated in
aspects which are developed separately and applied through aspect
weaving. This approach results in a more flexible approach for
generating and exploring the space of efficient dataflow designs.

Since \MAXC{} is compiled to a MaxCompiler design it uses the same
execution model: a design is composed of one or more computational
kernels (which implement the functionality we are interested in) which
are connected to form a design. Communication between kernels is
asynchronous, so kernels can operate independently of each other, and
a kernel will compute only when all it's active inputs have values
available.

\begin{table}[!h]
  \centering
\renewcommand{\arraystretch}{1.2}
\caption{Table summarising the main components of the \MAXC{} language.}
\label{table:maxc-features}
\begin{tabular}{l|l|l}
\hline
\bf{Feature}                   & \bf{Description}                   & \bf{Method (see Fig.~\ref{fig:maxc-1dconv})} \\
\hline\hline
  \multirow{2}{*}{Input/Output}         & Declared in function header          & C99 (line 1)                                 \\\cline{2-3}       & \texttt{in()},\texttt{out()}  & \MAXC{} API (lines 2,11) \\
\hline
  \multirow{2}{*}{Control}     & Ternary op., \texttt{if} statement & C99 (line 11)                                \\\cline{2-3}      & Stream mux (\texttt{mux()})       & \MAXC{} API  \\
\hline
\multirow{2}{*}{Computation} & +, *, /, -                         & C99 (line 8)                           \\\cline{2-3} & log, exp, sqrt, sin etc.  & \#include $<$math.h$>$  \\
\hline
  \multirow{2}{*}{Streams}     & Declared as pointers               & C99 (line 1)                                 \\\cline{2-3}       & Accessed with array index & C99 (line 8) \\
\hline
  Optimisation                 & C pragmas                   & C99 (line 7)                                 \\
\hline
  Parameterization             & Constants, variables                   & C99                                          \\
\hline
HW mapping                  & C pragmas                   & C99 (line 17)                                \\
\end{tabular}
\vspace{-0.4cm}
\end{table}

Table~\ref{table:maxc-features} summarises the features of \MAXC{} and
Fig.~\ref{fig:maxc-1dconv} shows an example dataflow kernel used to
value European options. Kernels are defined as regular C functions
with inputs clearly defined as arguments in the function
signature. Streams are represented as regular C99-style pointers.
Normal array notation can be used to generate either previous or
future values or dereference the stream to get the current stream
value. Negative indices are allowed for accessing previous stream
values and supported offset expressions are linear expressions
comprised of constants or variables (either loop induction variables,
or normal variables but for which a compile time range of values is
specified -- this is required to generate efficient
hardware). Constructs such as loops are supported as long as their
bounds are known at compile time and are used to parametrize dataflow
designs with values known at compilation time.

\lstset{style=MaxC}

\begin{figure}[!h]
  \begin{lstlisting}
    void Convolution1D_FPGA(float* p, float c_0_0_0, float c_p_0_0, float c_n_0_0, int n1, int ORDER) {
      in(p);

      float* i4 = count(1000, 1);
      float* i1 = countChain(n1, 1, i4);

      #pragma fast DSPBalance:full
      int result = p[0]  * c_0_0_0 + p[1]  * c_p_0_0 + p[-1] * c_n_0_0;

      int up =(i1 >= ORDER) && (i1 < n1 - ORDER);
      out(up ? result : p);
    }

    void Convolution1D_CPU(...) {...}

    int main() {
      #pragma fast hw:Convolution1D_FPGA
      Convolution1D_CPU(...);
    }
  \end{lstlisting}
  \caption{Example \MAXC{} design for a 1D convolution kernel.}
  \label{fig:maxc-1dconv}
\end{figure}


The \MAXC{} API provides higher-level constructs such as I/O
functions (\texttt{in()}, \texttt{out()}), counters
(Fig.~\ref{fig:maxc-1dconv}, Lines 4--5) and functions to multiplex
streams (\texttt{mux()}). C function calls are mapped to dataflow
kernels via pragmas (Line 17) which provides the flexibility of
selecting a particular dataflow configuration based on run-time
conditions (a more detailed example is discussed in Section
\ref{sect:asp_reconfig}).
