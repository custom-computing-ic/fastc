\section{The  MaxC Language}
\label{sec:maxc}

MaxC is a novel language for specifying dataflow designs that are used
as a starting point for the design proposed in Section
\ref{sec:design-flow}. In particular, we use
the C language as an intermediate language to capture the dataflow computation, and instead
of heavily relying on API libraries to specify the design (as in MaxJ
\cite{MaxelerTechnologies:2012} or Streams-C
\cite{Gokhale:Stone:Arnold:Kalinowski:2000}) we use aspects to
implement the transformations required for the actual implementation.

MaxC provides the following features that are
required by the proposed flow:

\begin{itemize}
\item Imperative specification of dataflow designs. Being based on the
  widely used C99 standard makes it familiar and easy to adopt for
  developers, facilitating translation of existing application code to
  dataflow designs.
\item Good interaction with existing source level translation and
  weaving tools. Simple syntax allows the language to interact well
  with existing compilers or source to source translation frameworks,
  allowing source level optimizations to be applied through different
  tools.
\item Combined hardware/software design. Specifications of dataflow
  kernels and CPU runtime software can be mixed. The example shown in
  Fig.~\ref{fig:maxc-1dconv} can be compiled with the GCC toolchain
  without any issues, but when using the MaxC compiler, the pragma
  indicates the link between the software and hardware, which results
  in an accelerated hardware software/solution.
\item Supports datapath and control path generation. MaxC allows
  specifying both datapath and control operations that are
  automatically mapped to stream multiplexers.
\end{itemize}

MaxC is designed to express the simplest form of a dataflow design
while optimizations and other transformations are encapsulated in
aspects which are developed separately and applied through aspect
weaving. This results in a more flexible approach for generating and
exploring the space of efficient dataflow designs.

Since MaxC is compiled to MaxJ it uses the same execution model: a
design is composed of one or more computational kernels (which
implement the functionality we are interested in) which are connected
to form a design. Communication between kernels is asynchronous, so
kernels can operate independently of each other but computation within
kernels is synchronous, so a kernel will compute only when all it's
active inputs have values available.

\begin{table}[!h]
  \centering
\renewcommand{\arraystretch}{1.2}
\caption{Table summarizing the main components of the MaxC language.}
\label{table:maxc-features}
\begin{tabular}{l|l|l}
\hline
\bf{Feature}                   & \bf{Description}                   & \bf{Method (see Fig.~\ref{fig:maxc-1dconv})} \\
\hline\hline
  \multirow{2}{*}{Input/Output}         & Declared in function header          & C99 (line 1)                                 \\\cline{2-3}       & \texttt{in()},\texttt{out()}  & MaxC API (lines 2,11) \\
\hline
  \multirow{2}{*}{Control}     & Ternary op., \texttt{if} statement & C99 (line 11)                                \\\cline{2-3}      & Stream mux (\texttt{mux()})       & MaxC API  \\
\hline
\multirow{2}{*}{Computation} & +, *, /, -                         & C99 (line 8)                           \\\cline{2-3} & log, exp, sqrt, sin etc.  & \#include $<$math.h$>$  \\
\hline
  \multirow{2}{*}{Streams}     & Declared as pointers               & C99 (line 1)                                 \\\cline{2-3}       & Accessed with array index & C99 (line 8) \\
\hline
  Optimization                 & C pragmas                   & C99 (line 7)                                 \\
\hline
  Parameterization             & Constants, variables                   & C99                                          \\
\hline
HW mapping                  & C pragmas                   & C99 (line 17)                                \\

\end{tabular}
\end{table}

Table~\ref{table:maxc-features} summarizes the features of MaxC and
Fig.~\ref{fig:maxc-1dconv} shows an example dataflow kernel which
implements a 1D convolution computation used to value European
options.  Kernels are defined as regular C functions with inputs
clearly defined in the kernel header. Streams are represented as
regular C99 pointers.  Normal array notation can be used to generate
either previous or future values or dereference the stream to get the
current stream value. Negative indices are allowed for accessing
previous stream values and supported offset expressions are linear
expressions comprised of constants or variables (either loop induction
variables, or normal variables but for which a compile time range of
values is specified -- this is required to generate efficient
hardware). Constructs such as loops are supported as long as their
bounds are known at compile time and are used to parametrize dataflow
designs with values known at compilation time.

\lstset{style=MaxC}

\begin{figure}[!h]
  \begin{lstlisting}
    void Convolution1D_FPGA(float* p, float c_0_0_0, float c_p_0_0, float c_n_0_0, int n1, int ORDER) {
      in(p);

      float* i4 = count(1000, 1);
      float* i1 = countChain(n1, 1, i4);

      #pragma maxc DSPBalance:full
      int result = p[0]  * c_0_0_0 + p[1]  * c_p_0_0 + p[-1] * c_n_0_0;

      int up =(i1 >= ORDER) && (i1 < n1 - ORDER);
      out(up ? result : p);
    }

    void Convolution1D_CPU(...) {...}

    int main() {
      #pragma maxc hw:Convolution1D_FPGA
      Convolution1D_CPU(...);
    }
  \end{lstlisting}
  \caption{Example MaxC design for a 1D convolution kernel.}
  \label{fig:maxc-1dconv}
\end{figure}


The MaxC API provides a limited number of higher-level constructs, such as I/O
functions (\texttt{in()} and \texttt{out()}, counters (Fig.~\ref{fig:maxc-1dconv},
Lines 4--5) and functions to multiplex streams (\texttt{mux()}).

%At the kernel level these dataflow elements are represented using:
%\begin{itemize}
%\item \emph{regular C constructs} are used as much as possible to make
%  the language more intuitive. This includes standard C99 types and
%  conventions for implementing kernels. Some overloaded operators are
%  provided such as the array access operators to provide a more
%  succinct syntax for accessing past or future stream elements;
%\item \emph{pragma directives} are used to convey additional
%  information to the compiler for which C99 does not provide flexible
%  built-in constructs (e.g. type width) or additional optimization
%  hints (e.g. DSP balance, Line 7);
%\item \emph{specific API calls} are used for higher level constructs.
%\end{itemize}
