\section{Introduction}

Existing work shows that dataflow machines emulated on FPGAs achieve
performance gains of up to several orders of magnitude compared to
traditional control based architectures \cite{Flynn:Pell:Mencer:2012},
\cite{Mencer:2012}. By eliminating the fetch-decode-execute cycle of
von Neumann architectures \cite{Neumann:1993}, dataflow designs
require less area for caching and control which increases performance
and decreases power consumption. Due to its regularity, a dataflow
design can be statically scheduled into a deep hazard-free pipeline,
achieving ideal throughput rates of one result per clock cycle. This
makes dataflow designs more suitable for implementing high throughput,
highly parallel applications that operate on large amounts of uniform
data than general purpose architectures. However, dataflow languages
are not commonly used and imperative languages such as Java, C and C++
are most popular \cite{Tiobe:2012}. We identify the following
challenges that should be overcome to facilitate the adoption of
dataflow designs:
\begin{enumerate}
\item Specifying dataflow designs, in an intuitive, well understood
  language that is concise and facilitates the translation of existing
  designs and expressive enough to support the requirements of modern
  high-performance applications.
\item Specifying optimization strategies, decoupled from the
  application code in a manner that makes the specification easy to
  reuse and customize and is comprehensive enough to allow capturing
  of optimizations at various levels: \emph{algorithmic
    transformations} of the original application to expose parallelism
  or improve communication between CPU and accelerator,
  \emph{design-level transformations} that enable exploration of
  platform specific optimizations and \emph{productivity related
    transformations} that improve developer productivity.
\item Systematic design space exploration of dataflow designs driven
  by these parameterizable optimization strategies, that increase
  developer productivity and allow exploration of design level
  trade-offs.
\item Applying these design techniques to create and optimize high
  performance applications.
\end{enumerate}

We propose a methodology for addressing these challenges based on the
following contributions:
\begin{enumerate}
\item We introduce MaxC, a dataflow language based on C99 that can be
  used to create high-performance designs. We implement a compiler
  that translates MaxC designs to MaxJ, an existing commercial dataflow
  language. These are then compiled using MaxCompiler 2012.1 and
  executed on a MAX3424 Board with a Virtex 6 FPGA chip and 48GB of
  on-board DRAM.
\item We introduce novel aspects for specifying optimisation
  strategies at the system level, the implementation level, the
  exploration level and development level. We implement these aspects using LARA~\cite{Cardoso:Carvalho:Cutinho:Luk:Nobre:Diniz:Petrov:2012}, an aspect
  oriented language for embedded reconfigurable systems.
\item We propose an automated method for design space exploration of
  MaxC dataflow designs, driven by the aspect definitions.
\item We evaluate our approach by implementing a high performance
  design for an application based on the Reverse Time Migration
  technique for seismic imaging.
\end{enumerate}
