\section{Introduction}

Existing work shows that dataflow machines emulated on FPGAs achieve
performance gains of up to several orders of magnitude compared to
traditional control based architectures \cite{Flynn:Pell:Mencer:2012},
\cite{Mencer:2012}. By eliminating the fetch-decode-execute cycle of
von Neumann architectures \cite{Neumann:1993}, dataflow designs
require less area for caching and control which increases performance
and decreases power consumption. Due to its regularity, a dataflow
design can be statically scheduled into a deep hazard-free pipeline
through which data is streamed, achieving ideal throughput rates of
one result per clock cycle. The stream based execution model is better
suited for implementing high throughput, highly parallel applications
that operate on large amounts of uniform data streams than general
purpose architectures. However, dataflow languages are not commonly
used and imperative languages such as Java, C and C++ are most popular
\cite{Tiobe:2012}. We identify the following challenges that should be
overcome to facilitate the adoption of dataflow designs:
\begin{enumerate}
\item Specifying dataflow designs, in an intuitive, well understood
  language that is concise and facilitates the translation of existing
  designs and expressive enough to support the requirements of modern
  high-performance applications.
\item Specifying optimisation strategies, decoupled from the
  application code in a manner that makes the specification easy to
  reuse and customise and is comprehensive enough to allow capturing
  of optimisations at various levels: \emph{algorithmic
    transformations} of the original application to expose parallelism
  or improve communication between CPU and accelerator,
  \emph{design-level transformations} that enable exploration of
  platform specific optimisations and \emph{productivity related
    transformations} that improve developer productivity.
\item Systematic design space exploration of dataflow designs driven
  by these parameterizable optimisation strategies, that increase
  developer productivity and allow exploration of design level
  trade-offs.
\item Applying these design techniques to create and optimise
  high-performance applications.
\end{enumerate}

We propose a methodology for addressing these challenges based on the
following contributions:
\begin{enumerate}
\item We introduce \MAXC{}, a dataflow language based on C99 that can
  be used to create high-performance designs. We implement a compiler
  that translates \MAXC{} designs to MaxCompiler designs [\XXX{Ref
      required}] which are then compiled and executed on a MAX3424
    Board with a Virtex 6 FPGA chip and 48GB of on-board DRAM.
\item We introduce novel aspects for specifying optimisation
  strategies at the system level, the implementation level, the
  exploration level and development level. We implement these aspects
  using
  LARA~\cite{Cardoso:Carvalho:Cutinho:Luk:Nobre:Diniz:Petrov:2012}, an
  aspect oriented language for embedded reconfigurable systems.
\item We propose an automated method for design space exploration of
  \MAXC{} dataflow designs, driven by the aspect definitions.
\item We evaluate our approach by implementing a high-performance
  design for an application based on the Reverse Time Migration
  technique for seismic imaging.
\end{enumerate}
