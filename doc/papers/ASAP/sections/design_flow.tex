\section{Design Flow}
\label{sec:design-flow}

We propose a novel design flow for aspect-driven compilation of
dataflow designs to meet the following requirements and design goals,
addressing key areas in developing hardware acceleration solutions:
\begin{enumerate}
\item \emph{Performance:} specify high performance dataflow designs, that
  achieve significant speedup over software only versions; exploit the
  run-time reconfiguration capability of FPGA devices to improve
  performance and efficiency;
\item \emph{Portability:} improve portability of dataflow designs, to
  allow reuse of optimization strategies on various platforms;
\item \emph{Integration:} simplify translation of existing
  applications to high performance dataflow designs to facilitate the
  integration of the proposed design flow with existing (predominantly
  imperative) application code;
\item \emph{Productivity:} improve developer productivity by providing
  high-level means of specifying dataflow designs, controlling
  compilation strategies to reduce compilation time and generating
  boilerplate code automatically.
\end{enumerate}

To meet these requirements we propose the following approach. Firstly,
we introduce MaxC (described in Section \ref{sec:maxc}), a novel
language for specifying dataflow designs that provides support for
run-time reconfiguration. We specify the accelerated portion of the
original applications using MaxC dataflow kernels. By maintaining
compatibility with the C99 standard we improve developer productivity
by providing a familiar language and introduce the possibility of
mixing hardware/software specifications. Secondly, by using an aspect
driven compilation flow we decouple optimization from design
development, improving design portability, and we automate the
generation of code and design space exploration improving
productivity. Finally, systematic design space exploration is used to
identify maximum performance configurations, subject to platform
specific constraints.

The proposed design flow is illustrated in Figure
\ref{fig:design-flow} and follows the steps: (i) a C application
containing an embedded high-level dataflow design is developed from
the original source application (implemented using MaxC, described in
Section \ref{sec:maxc}), (ii) the dataflow design is transformed
(``woven'') by the aspects in the repository to generate new designs
(e.g with support for run-time reconfiguration, with various
word-length configurations and various compilation times -- these are
covered in detail in Section \ref{sec:aspects}), (iii) the generated
configurations are compiled using a backend compilation toolchain (in
our case MaxCompiler) to FPGA designs, (iv) the feedback from the
compilation process is used to drive the design space exploration,
repeating the weaving and compilation process until user specified
requirements are met.

\begin{figure}[!h]
  \includegraphics[scale=0.51, trim=72 50 0 0]{figs/design-flow}
  \caption{The proposed design flow.}
  \label{fig:design-flow}
\end{figure}

Compared to existing work described in
\cite{Cardoso:Teixeira:Alves:Nobre:Diniz:Cutinho:Luk:2012} and
\cite{cardoso2011new} our approach emphasises and provides more
freedom in the exploration of design level optimization (such as word
length optimizations and mapping of arithmetic blocks to DSPs) by
using a combination of implementation aspects (shown in Figure
\ref{fig:design-flow}) and MaxC optimization options.  Additionally
our approach targets a dataflow architecture as opposed to the von
Neumann architecture (GPP + Custom accelerator) proposed in the
related work. We explicitly consider and implement run-time
reconfiguration to achieve performance improvements. Finally we use
the C language itself to capture the dataflow computation and instead
of heavily relying on API libraries to specify the design (as in MaxJ
\cite{MaxelerTechnologies:2012} or Streams-C
\cite{Gokhale:Stone:Arnold:Kalinowski:2000}) we use aspects to
implement the transformations required for the actual implementation.
