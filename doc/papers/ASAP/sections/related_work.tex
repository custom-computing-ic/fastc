\section{Related Work}

A number of dataflow languages have been developed targeting FPGAs but
also multi-core platforms. Table \ref{table:feature-comparison}
summarises some of the important features of these languages compared
to \MAXC{}. Lucid \cite{ashcroft1977lucid}, SISAL
\cite{gurd1987implicit}, \cite{mcgraw1983sisal} and Lustre
\cite{halbwachs1991synchronous}, are examples of functional dataflow
languages. The latter is based on a synchronous programming model,
facilitating safety verification for critical software
\cite{halbwachs1992programming} rather than performance. The
functional programming style complicates the translation of existing
imperative applications and none have existing implementations for
FPGAs, so a performance comparison is not possible.
Streams-C\cite{Gokhale:Stone:Arnold:Kalinowski:2000} and
ImpulseC\cite{ImpulseC} use imperative ANSI C syntax and an execution
model based on Communicating Sequential Processes and introduce
non-standard syntax and constructs for specifying designs such as
special comment blocks which are used to annotate the C application
code. The specialised syntax makes the languages harder to integrate
with existing source-to-source translation or aspect weaving
frameworks. Hybrid approaches such as MaxCompiler\cite{5719584}
separate the CPU run-time component from the accelerated one,
providing a C run-time environment and a Java API for building
dataflow designs via meta-programming. The separation complicates the
development process, hindering sharing of design parameters and,
consequently, the design space exploration process. The use of
meta-programming simplifies design parametrisation, but can make
resulting programs harder to understand. By contrast, the proposed
approach allows the CPU and dataflow components to be specified using
a single language and separates design parametrisation from
computation, resulting in a more intuitive implementation.

\begin{table}[!h]
  \renewcommand{\arraystretch}{1.2}
  \centering
  \caption{Feature comparison of \MAXC{} and other dataflow languages.}
  \label{table:feature-comparison}
  \begin{tabular}{ c |  c |  c |  c |  c }
    \hline
    \           & \bf{Syntax} & \bf{Paradigm} & \bf{Impl.} & \bf{Support} \\
    \hline \hline
    Lucid       & Lucid       & Func.         & Multiproc. & Software     \\
    SISAL       & SISAL       & Func.         & Multiproc. & Software     \\
    Lustre      & Lustre      & Sync.         & Multiproc. & Software     \\
    MaxCompiler & Java        & Imp.          & FPGA       & Hardware     \\
    Streams-C   & C           & Imp./CSP      & FPGA       & Combined     \\
    ImpulseC    & C           & Imp./CSP      & Both       & Combined     \\
    \MAXC{}     & C           & Imp.          & FPGA       & Combined     \\
  \end{tabular}
\end{table}

The use of LARA aspects in guiding the compilation process of C
application is also described in
\cite{Cardoso:Teixeira:Alves:Nobre:Diniz:Cutinho:Luk:2012} and
\cite{cardoso2011new} but the backend compilation targets a von
Neumann architecture (GPP + custom accelerator units) unlike the
dataflow architecture proposed in this paper. The approach described
in \cite{Cardoso:Teixeira:Alves:Nobre:Diniz:Cutinho:Luk:2012} and
\cite{cardoso2011new} relies more on high-level source transformation
whereas our approach is based on a more systematic design level
exploration process, which enables the analysis of more low-level
optimisations. Finally,
\cite{Cardoso:Teixeira:Alves:Nobre:Diniz:Cutinho:Luk:2012} and
\cite{cardoso2011new} do not consider development aspects which can be
used to improve developer productivity and run-time reconfiguration
aspects that can lead to improved performance.

The use of aspect-oriented programming for specifying strategies for
run-time adaptation of FPGA designs discussed in \cite{6322875}
differs from the static process considered in this paper in which the
run-time reconfiguration aspects generate and schedule all partitions
of the application at compile time, to achieve optimal performance as
described in \cite{Xinyu:Qiwei:Luk:Qiang:Pell:2012}. One advantage of
our approach is that an optimal allocation is generated from the
start. However we do not have the flexibility of adapting the design
to varying input conditions.
