\section{Related Work}

A number of dataflow languages have been developed targeting FPGAs but
also multi-core platforms. Table \ref{table:feature-comparison}
summarises some of the important features of these languages compared
to \MAXC{}.

Lucid \cite{ashcroft1977lucid}, SISAL \cite{gurd1987implicit},
\cite{mcgraw1983sisal} and Lustre \cite{halbwachs1991synchronous}, are
examples of functional dataflow languages. The latter is based on a
synchronous programming model, facilitating safety verification for
critical software \cite{halbwachs1992programming} rather than
performance. The functional programming style complicates the
translation of existing imperative applications and none have existing
implementations for FPGAs, so a performance comparison is not
possible.

Streams-C\cite{Gokhale:Stone:Arnold:Kalinowski:2000} and
ImpulseC\cite{ImpulseC} adopt imperative ANSI C syntax and an
execution model based on Communicating Sequential Processes and
introduce non-standard syntax and constructs for specifying designs
such as special comment blocks which are used to annotate the C
application code. The specialised syntax makes the languages harder to
integrate with existing source-to-source translation or aspect weaving
frameworks.

Hybrid approaches such as MaxCompiler\cite{5719584} separate the CPU
run-time component from the accelerated one, providing a C run-time
environment and a Java API for building dataflow designs via
meta-programming. The separation complicates the development process,
hindering sharing of design parameters and, consequently, the design
space exploration process. The use of meta-programming simplifies
design parametrisation, but can make resulting programs harder to
understand. In contrast, the proposed approach allows the computation
description, which includes CPU and dataﬂow components, to be speciﬁed
using a single language and to be decoupled from design
parametrisation and other optimisation strategies which are captured
as LARA aspects. This separation of concerns results in more intuitive
and maintainable descriptions.

\begin{table*}[!ht]
  \renewcommand{\arraystretch}{1.8}
  \centering
  \caption{Feature comparison of the \MAXC{}/LARA approach and existing dataflow implementations.}
  \label{table:feature-comparison}
  \begin{tabular}{ p{1.7cm} |  p{1.8cm} |  p{1.8cm} |  c | c | l | l}
    \hline
    \bf{Language}          & \bf{Syntax}          & \bf{Paradigm}               & \bf{Support}              & \bf{Implementation}   & \bf{Design Parametrisation}            & \bf{Optimisation Strategies}          \\
    \hline \hline
    \bf{Lucid}                    & Lucid                & Functional                  & \multirow{3}{*}{Software}                  & \multirow{3}{*}{Multiprocessor}        & \multirow{3}{*}{\begin{minipage}{0.7in}Manual Source Transformation\end{minipage}} & \multirow{5}{*}{Manual Code Revision} \\
    \bf{SISAL}                    & SISAL                & Functional                  &                &    &                                        &                                       \\
    \bf{Lustre}                   & Lustre               & Synchronous                 &               &        &                                        &                                       \\
    \cline{1-6}
    \multirow{2}{*}{\bf{MaxCompiler}}              &  \multirow{2}{*}{\begin{minipage}{0.5in}C99(SW) Java(HW)\end{minipage}} &  \multirow{2}{*}{\begin{minipage}{1in}Imperative(SW) Dataflow(HW)\end{minipage}}      & \multirow{5}{*}{Combined}                  & \multirow{5}{*}{CPU + FPGA}                  & \multirow{2}{*}{Meta-programming}                      &                                       \\
    \cline{1-3}\cline{6}
    \multirow{2}{*}{\begin{minipage}{0.6in}\bf{Streams-C} \bf{ImpulseC}\end{minipage}}                & \multirow{2}{*}{C99}                  &      \multirow{2}{*}{\begin{minipage}{1in}Imperative(SW) CSP(HW)\end{minipage}}              &                   &                & \multirow{2}{*}{Compiler Directives}   &                                       \\
     \cline{1-3}\cline{6-7}
    \multirow{2}{*}{\bf{\MAXC{}}/\bf{LARA}} & \multirow{2}{*}{\begin{minipage}{1in}C99(SW) LARA(Aspects)\end{minipage}} & \multirow{2}{*}{\begin{minipage}{1in}Imperative(SW) Dataflow(HW) AOP(Aspects)\end{minipage}} &  & & \multicolumn{2}{c}{\multirow{2}{*}{\begin{minipage}{2.3in}Compiler Directives + \\ Automated Aspect-Directed Source Transformation\end{minipage}}}
                                                                                                                                \\
  \end{tabular}
\end{table*}

The use of LARA aspects in guiding the compilation process of C
applications is described in
\cite{Cardoso:Teixeira:Alves:Nobre:Diniz:Cutinho:Luk:2012} and
\cite{cardoso2011new} but the backend compilation targets a von
Neumann architecture (GPP + custom accelerator units) unlike the
dataflow architecture proposed in this paper. The approach described
in \cite{Cardoso:Teixeira:Alves:Nobre:Diniz:Cutinho:Luk:2012} and
\cite{cardoso2011new} relies more on high-level source transformation
whereas our approach is based on a systematic design space exploration
process, which enables the analysis of more low-level
optimisations. Finally,
\cite{Cardoso:Teixeira:Alves:Nobre:Diniz:Cutinho:Luk:2012} and
\cite{cardoso2011new} do not consider development aspects which can be
used to improve developer productivity.

The use of aspect-oriented programming for specifying strategies for
run-time adaptation of FPGA designs discussed in \cite{6322875}
differs from the static process considered in this paper in which the
application is partitioned and scheduled at compile time, to achieve
optimised performance as described in
\cite{Xinyu:Qiwei:Luk:Qiang:Pell:2012}. An advantage of our approach
is that an optimised allocation is generated prior to application
execution. However, we lack the flexibility of adapting the design to
varying input conditions.
