\section{Related Work}

\subsection{Dataflow Languages}

A number of dataflow languages have been developed targeting FPGAs but
also multi-core platforms. Lucid \cite{ashcroft1977lucid} is an early
example of a functional pipeline based dataflow language. No
performance benefits are described in \cite{ashcroft1977lucid} and
\cite{ashcroft1980some} shows that there are Lucid programs which
cannot be converted to dataflow graphs. The language is platform
agnostic, but no implementations for FPGAs exist -- only pLucid
\cite{pLucid} for UNIX is available. SISAL \cite{gurd1987implicit},
\cite{mcgraw1983sisal} is another example of a functional style
dataflow programming language. It can be used to output a dataflow
graph in the IF1 representation. Results show that parallel SISAL
designs can be faster \cite{archambault2010fine} than C or Fortran on
traditional shared memory multiprocessors but no figures exist for
FPGA architectures. Various extensions for control flow and
synchronization have been investigated in \cite{143862} and
\cite{183202}. Lustre \cite{halbwachs1991synchronous} is a dataflow
language based on the synchronous programming paradigm which is
focused on building and proving the correctness of safety critical
software \cite{halbwachs1992programming} rather than performance.  All
approaches described so far use a functional programming style which
would complicate the translation of existing imperative applications,
the predominant style currently in use. Furthermore none have existing
implementations for FPGAs, so a performance comparison is not possible
and extensions would be required to support creation of
high-performance designs that enable platform specific optimisations.
Streams-C\cite{Gokhale:Stone:Arnold:Kalinowski:2000} and
ImpulseC\cite{ImpulseC} use a model based on Communicating Sequential
Processes and introduce non-standard syntax and constructs for
specifying designs such as special comment blocks which are used to
annotate the C application code. This makes the languages harder to
integrate with existing source-to-source translation or aspect weaving
frameworks.

Hybrid approaches such as MaxCompiler \cite{MaxelerTechnologies:2012}
exist that have been specifically designed for accelerating software
applications with an FPGA based accelerator. MaxCompiler separates the
CPU runtime part of the application from the accelerated part,
providing an imperative C based runtime environment and a Java
dataflow API for specifying the dataflow accelerator designs. This
leads to a separation between the two components and complicates the
development process, since developers have to manage the two
separately (using two different languages and tool sets). This
complicates information sharing between the two components (such as
common design parameters) and, consequently, the design space
exploration process. One of the advantages of using Java as a
programming language is that it improves code modularisation but we
find that in practice, dataflow designs rarely reach sizes which make
this a serious benefit.

\subsection{Aspect Driven Design}


\subsection{Comparison with Other Dataflow Languages}

Table \ref{table:feature-comparison} summarizes the features of MaxC
in comparison with other languages described in the related works
section.

\begin{table}[!h]
  \renewcommand{\arraystretch}{1.3}
  \centering
  \caption{Feature comparison of MaxC and other dataflow languages.}
  \label{table:feature-comparison}
  \begin{tabular}{ l | c |  p{1cm} |  p{1cm} |  c |  c }
    Language  & Syntax & FPGA Support & Execution Model & Debugging & Simulation \\ \hline
    MaxJ      & -      & -            & -               & -         & -          \\
    Streams-C & -      & -            & -               & -         & -          \\
    ImpulseC  & -      & -            & -               & -         & -          \\
    StreamIt  & -      & -            & -               & -         & -          \\
    Sequoia++ & -      & -            & -               & -         & -          \\
    MaxC      & -      & -            & -               & -         & -          \\
  \end{tabular}
\end{table}


\begin{comment}
  \subsubsection{Translation}

  Translation aspects tranform high-level source code to MaxC designs.

  Aspect steps:
  \begin{enumerate}

  \item identify acceleration candidates by profiling the
    computation. In particular analyse loops with computations and
    profile at various degrees of nesting;

  \item transform local arrays to dynamic arrays;

  \item extract computational kernel by mapping the outer loop to the
    stream loop;

  \item generate runtime API (currently using MaxCompilerRT).

  \end{enumerate}

  This aspect will map the C99 application shown in Figure
  \ref{fig:c-design} to Lines 12 -- 16 of the 1D Convolution kernel in
  Figure \ref{fig:maxc-1dconv}.


  \begin{figure}[!h]
    \centering
    \begin{lstlisting}
      void kernel(int source[], int m, float a_0_0_0, float a_p1_0_0, float a_m1_0_0) {

        for(j=1; j<m; j++){
          target[j] =
          source[j]  * a_0_0_0
          + source[j + 1] * a_p1_0_0
          + source[j - 1] * a_m1_0_0;
        }

      }
    \end{lstlisting}
    \caption{Original C99 source code for the 1D convolution kernel in
      Figure \ref{fig:maxc-1dconv}.}
    \label{fig:c-design}
  \end{figure}
\end{translation}

\subsubsection{\TODO Parallelism}
\end{comment}
