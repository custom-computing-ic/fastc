\section{Related Work}

A number of dataflow languages have been developed targeting FPGAs but
also multi-core platforms. Table \ref{table:feature-comparison}
summarizes some of the important features of these languages compared
to MaxC. Lucid \cite{ashcroft1977lucid}, SISAL
\cite{gurd1987implicit}, \cite{mcgraw1983sisal} and Lustre
\cite{halbwachs1991synchronous}, are examples of functional dataflow
languages. The latter is based on a synchronous programming model,
facilitating safety verification for critical software
\cite{halbwachs1992programming} rather than performance. The
functional programming style complicates the translation of existing
imperative applications and none have existing implementations for
FPGAs, so a performance comparison is not possible.
Streams-C\cite{Gokhale:Stone:Arnold:Kalinowski:2000} and
ImpulseC\cite{ImpulseC} use imperative ANSI C syntax and an execution
model based on Communicating Sequential Processes and introduce
non-standard syntax and constructs for specifying designs such as
special comment blocks which are used to annotate the C application
code. This makes the languages harder to integrate with existing
source-to-source translation or aspect weaving frameworks. Hybrid
approaches such as MaxCompiler \cite{MaxelerTechnologies:2012}
separate the CPU runtime component from the accelerated one, providing
an imperative C based runtime environment and a Java dataflow API for
building the accelerator designs. This separation complicates the
development process, since the two components have to be managed
separately and hinders information sharing between the two components
(such as common design parameters) and, consequently, the design space
exploration process.

\begin{table}[!h]
  \renewcommand{\arraystretch}{1.2}
  \centering
  \caption{Feature comparison of MaxC and other dataflow languages.}
  \label{table:feature-comparison}
  \begin{tabular}{ c |  c |  c |  c |  c }
    \hline
    \         & \bf{Syntax} & \bf{Paradigm} & \bf{Impl.} & \bf{Support} \\
    \hline \hline
    Lucid     & Lucid       & Func.         & Multiproc. & Software     \\
    SISAL     & SISAL       & Func.         & Multiproc. & Software     \\
    Lustre    & Lustre      & Sync.         & Multiproc. & Software     \\
    MaxJ      & Java        & Imp.          & FPGA       & Hardware     \\
    Streams-C & C           & Imp./CSP      & FPGA       & Combined     \\
    ImpulseC  & C           & Imp./CSP      & Both       & Combined     \\
    MaxC      & C           & Imp.          & FPGA       & Combined     \\
  \end{tabular}
\end{table}

The use of LARA aspects in guiding the compilation process of C
application is also described in
\cite{Cardoso:Teixeira:Alves:Nobre:Diniz:Cutinho:Luk:2012} and
\cite{cardoso2011new} but the backend compilation targets a von
Neumann architecture (GPP + custom accelerator units) unlike the
dataflow architecture proposed in this paper. The approach described
in \cite{Cardoso:Teixeira:Alves:Nobre:Diniz:Cutinho:Luk:2012} and
\cite{cardoso2011new} relies more on high-level source transformation
whereas our approach is based on a more systematic design level
exploration process, which enables the analysis of more low-level
optimisations. Finally,
\cite{Cardoso:Teixeira:Alves:Nobre:Diniz:Cutinho:Luk:2012} and
\cite{cardoso2011new} do not consider development aspects which can be
used to improve developer productivity and run-time reconfiguration
aspects that can lead to improved performance.

The use of aspect-oriented programming for specifying strategies for
run-time adaptation of FPGA designs is discussed in
\cite{6322875}. This is different than the static process considered
in this paper in which the run-time reconfiguration aspects generate
and schedule all partitions of the application at compile time, to
achieve optimal performance as described in
\cite{Xinyu:Qiwei:Luk:Qiang:Pell:2012}. One advantage of our approach
is that an optimal allocation is generated from the start. However we
do not have the flexibility of adapting the design to varying input
conditions.
