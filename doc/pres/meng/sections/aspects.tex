\section{Aspect Descriptions}
\begin{frame}
  \frametitle{3. Aspect Descriptions}
\begin{enumerate}
\item \textbf{System Aspect Descriptions} -- applied at the whole
  system level (FAST + C application) to capture the mapping
  between application modules and accelerator
\item \textbf{Implementation Aspect Descriptions} -- applied at the
  level of the dataflow design, to perform platform specific
  optimisations
\item \textbf{Exploration Aspect Descriptions} -- used to explore the
  design space of optimisation trade-offs
\item \textbf{Development Aspect Description}  -- used to support
    the development process
\end{enumerate}
\end{frame}

\begin{frame}
  \frametitle{3. Aspect Descriptions: System Aspects}
Hardware/Software Partitioning:
\begin{enumerate}
  \item detect hotspots
  \item detect code patterns suitable for acceleration
  \item perform outlining transformation
  \item derive dataflow \texttt{fast\_f()} from \texttt{f()}
  \item place FAST pragma to link \texttt{fast\_f()} with \texttt{f()}
\end{enumerate}
\end{frame}


\begin{frame}[fragile]
  \frametitle{3. Aspect Descriptions: Monitoring}
  For all innermost loops:
\begin{itemize}
  \item Monitor every loop iteration
  \item Monitor every loop entry and exit
\end{itemize}
\begin{lstlisting}[label=lst:label, style=lara]
aspectdef LoopMonitor
  function.loop{is_innermost}:
    entry:   prepend(mon_iterationIn());
    exit :   append (mon_iterationOut());
    default: prepend(mon_instanceIn());
             append(mon_instanceOut());
end
\end{lstlisting}
\end{frame}

\begin{frame}{3. Aspect Descriptions: Run-time Reconfiguration}
Explain why run-time reconfiguration is useful
\end{frame}

\begin{frame}{3. Aspect Descriptions: Run-time Reconfiguration}
Show aspects for run-time reconfiguration and general strategy
\end{frame}

\begin{frame}[fragile]{3. Aspect Descriptions: Operator Optimisation}
\begin{lstlisting}[label=lst:label, style=lara]
aspectdef DspBalancing
var op_granularity =
 [{DspBalance:’full’,MultiplyOp: 5,AddOp: 5 },
  {DspBalance:’balanced’,MultiplyOp:3}];

select function.statement end
apply
 for (var i in op_granularity) {
   var gprofile = op_granularity[i];
   var match = true;
   for (var k in gprofile) {
     if (k != ’DspBalance’) {
       match &= ($statement.num_construct(k)
                 >= gprofile[k]);}}
   if (match) {
     var pragma = ’#pragma FAST balanceDSP:’
                   + gprofile.DspFactor;
     $statement.insert before "[[pragma]]";
     break;}}
   end
end
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{3. Aspect Descriptions: Exploration Aspects}
\begin{lstlisting}[label=lst:label, style=lara]
aspectdef DesignExploration
  input
   attribute,
   start, step,
   resource, resource_threshold,
   config
end
config[attribute] = start;
var i = 0;
do {
  var designName = genName(config);
  call genFAST(designName, config);
  buildFAST(designName);
  config[attribute] += step; i++;
} while (@hw[designName]. resource < resource_threshold && i < LIMIT);
end
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{3. Aspect Descriptions: Development Aspects}
\begin{lstlisting}[label=lst:label, style=lara]
aspectdef WatchVar
select function.vref end
apply
  $vref.parent_stmt.insert before
  %{ log("[[$vref.name]]", [[$vref.name]]); }%
  $vref.parent_stmt.insert after
  %{ log("[[$vref.name]]", [[$vref.name]]); }%
end
condition $vref.is_out end
end
\end{lstlisting}

\begin{itemize}
\item useful since no run-time is debugger available
\item aspect descriptions automatically log values of variables on assignment
\end{itemize}
\end{frame}
