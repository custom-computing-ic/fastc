\section{Aspect Descriptions}
\begin{frame}
  \frametitle{3. Aspect Descriptions}
  \begin{enumerate}
  \setlength{\itemsep}{15pt}
  \item \textbf{System Aspect Descriptions} -- applied at the whole
    system level (FAST + C application) to capture the mapping
    between application modules and accelerator
  \item \textbf{Implementation Aspect Descriptions} -- applied at the
    level of the dataflow design, to perform platform specific
    optimisations
  \item \textbf{Exploration Aspect Descriptions} -- used to explore the
    design space of optimisation trade-offs
  \item \textbf{Development Aspect Descriptions}  -- used to support
    the development process
  \end{enumerate}
\end{frame}

\begin{frame}
  \frametitle{3. Aspect Descriptions}
  \framesubtitle{3.1 System Aspect Descriptions}
  Hardware/Software Partitioning:
  \begin{enumerate}
  \setlength{\itemsep}{10pt}
  \item detect hotspots
  \item detect code patterns suitable for acceleration
  \item perform outlining transformation
  \item derive dataflow \texttt{fast\_f()} from \texttt{f()}
  \item place FAST pragma to link \texttt{fast\_f()} with \texttt{f()}
  \end{enumerate}
\end{frame}


\begin{frame}[fragile]
  \frametitle{3. Aspect Descriptions}
  \framesubtitle{3.2 System Aspect Descriptions: Monitoring}
  For all innermost loops:
  \begin{itemize}
  \item Monitor every loop iteration
  \item Monitor every loop entry and exit
  \end{itemize}
  \begin{lstlisting}[label=lst:label, style=lara]
aspectdef LoopMonitor
function.loop{is_innermost}:
  entry:   prepend(mon_iterationIn())
  exit :   append (mon_iterationOut())
  default: prepend(mon_instanceIn())
           append(mon_instanceOut())
end
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{3. Aspect Descriptions}
  \framesubtitle{3.3 System Aspect Descriptions: Run-time Reconfiguration}
  \begin{itemize}
  \item Run-time reconfiguration can be used to remove idle
    functions. Optimal partitions are generated statically.
  \item FAST pragmas can specify configurations, grouping one
    or more functions.
    \begin{columns}
      \begin{column}{.55\textwidth}
        \begin{center}
    \begin{lstlisting}[style=MaxC]
      x = f(0);
      #pragma fast hw:f1 cfg:c1
      y = f(x);
      #pragma fast hw:g1 cfg:c1
      z = g(x);
    \end{lstlisting}
    \end{center}
    \end{column}
    \begin{column}{.45\textwidth}
      {\footnotesize
      \begin{table}[!h]
        \renewcommand{\arraystretch}{1.1}
      \hspace{-1cm}
        \begin{tabular}{c|c|c}
          \multicolumn{3}{c}{\bf{partition}} \\
          \hline
          \bf{call.key} & \bf{hw} & \bf{cfg}  \\
          \hline
          main:f:1 & fast\_f0 & c0 \\
          main:f:2 & fast\_f1 & c1 \\
          main:g:3 & fast\_g & c1 \\
        \end{tabular}
      \end{table}
    }
    \end{column}
    \end{columns}
  \item Due to data-dependency one function may be idle => load a
    different configuration for the useful functions in its place,
    reducing overall computation time
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{3. Aspect Descriptions}
  \framesubtitle{3.4 System Aspect Descriptions: Run-time Reconfiguration}
  Map function calls (on the CPU side) to configurations:
  \begin{itemize}
  \item inspect each function call
  \item if part of a partition, add corresponding FAST pragma
  \item $ \text{partition} : \text{funcCall} \rightarrow (\text{kernel}, \text{config}) $
  \end{itemize}

  \begin{lstlisting}[style=lara]
aspectdef AspReconfig
input: partition
function.call:
  if (call.key in partition) {
    config = partition[call.key].cfg;
    kernel = partition[call.key].hw;
    call.prepend('#pragma fast hw:'kernel' cfg:'config)
  }
end
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{3. Aspect Descriptions}
  \framesubtitle{3.5 Implementation Aspect Descriptions: Operator Optimisation}
  Map computation to Digital Signal Processors:
  \begin{itemize}
  \item $ \text{opMapping} : \overrightarrow{\text{opOccurence}} \rightarrow \text{factor}$
  \item $\text{factor} \in \{\text{none}, \text{balanced}, \text{full}\} $
  \item mapping can be varied by different aspect to support design
    space exploration
  \end{itemize}
  \begin{lstlisting}[label=lst:label, style=lara]
aspectdef DspBalancing
input: opMapping
function.stmt:
  opUsage = countOperatorUsage(stmt)
  factor  = opMapping[opUsage]
  if (factor != '')
    stmt.prepend('#pragma fast balanceDSP:' + factor);
end
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{3. Aspect Descriptions}
  \framesubtitle{3.6 Exploration Aspect Descriptions: Iterative Exploration}
  Automate design space exploration
  \begin{itemize}
  \item vary an attribute of a dataflow configuration
  \item generate FAST configuration and compile FPGA bitstream
  \item extract feedback from compilation report
  \item stop when a resource usage limit is reached
  \end{itemize}
  \begin{lstlisting}[label=lst:label, style=lara]
aspectdef DesignExploration
input: attribute, start, step, res, res_limit, config
  config[attribute] = start
  do {
    var designName = genName(config)
      generateFASTDesign(designName, config)
      buildFASTDesign(designName)
      config[attribute] += step
    } while (@hw[designName].res < res_limit)
end
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]{3. Aspect Descriptions}
  \framesubtitle{3.7: Development Aspect Descriptions: Variable Watching}
  For all variable references:
  \begin{itemize}
  \item Automatically log variables on assignment
  \item Useful since no run-time is debugger available
  \end{itemize}
  \begin{lstlisting}[label=lst:label, style=lara]
aspectdef WatchVar
function.vref{is_written}:
  vref.parent.prepend('log("vref.name", vref.name)')
  vref.parent.append('log("vref.name", vref.name)')
end
  \end{lstlisting}
\end{frame}
