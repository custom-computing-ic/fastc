\chapter{Aspect Descriptions}
\label{sec:aspects}

Aspects descriptions are modules that capture functional cross-cutting
concerns that are decoupled from the primary function of a program. In
traditional Aspect-oriented approaches, program execution points
(e.g. method calls) are intercepted at run-time to allow new code to
be executed before, after or in place of these execution points. The
process through which this is achieved is called \emph{weaving}. The
main motivation behind AOP is to solve the modularisation problem when
dealing with multiple cross-cutting functional concerns.

The LARA aspect-oriented design-flow
\cite{Cardoso:Carvalho:Cutinho:Luk:Nobre:Diniz:Petrov:2012}, depicted
in \Cref{fig:aspect-weaving}, performs the weaving process at
compile-time to meet non-functional optimisation goals, such as
improving application performance on particular hardware
platforms. The weaving process manipulates and transforms the
application sources generating new sources (woven code) that
incorporate both functional elements of the original sources, and
non-functional concerns captured by LARA aspects.

\begin{figure}[!ht]
  \centering
  \def\svgwidth{\textwidth}
  \input{figs/meng-aspect-weaving.pdf_tex}
  \caption{Aspect weaving overview.}
  \label{fig:aspect-weaving}
\end{figure}
In this project we combine the LARA aspect design-flow with \FAST{}
dataflow designs. As explained in \Cref{sec:fast}, \FAST{} uses
standard C99 syntax to capture dataflow computations while aspects
specify decoupled optimisation and transformation strategies that
operate on \FAST{} descriptions. This approach makes the functionality
of the application easier to understand, more maintainable and
portable since it is no longer obscured by various structural or
algorithmic transformations, or platform specific optimisations. In
addition, strategies coded in LARA can be re-applied automatically in
different applications, thus improving developer productivity.

We introduce novel aspect descriptions to use with \FAST{} dataflow
designs, which we group in four main classes as shown in
\Cref{tbl:aspects}:

\begin{itemize}
\item \textbf{System Aspect Descriptions} are applied at the whole
  system level (\FAST{} + C application) to capture the mapping
  between application modules and accelerator
\item \textbf{Implementation Aspect Descriptions} are applied at the
  level of the dataflow design, to apply platform specific
  optimisations
\item \textbf{Exploration Aspect Descriptions} are used to explore the
  design space of optimisation trade-offs
\item \textbf{Development Aspect Description} are used to support
    the development process
\end{itemize}

\begin{table}[tp]
\caption{Types of Aspects used in \FAST{}}
\renewcommand{\arraystretch}{1.2}
\label{tbl:aspects}
\centering
\begin{tabular}{l|l|l}
\hline
\bf{Aspect Type} & \bf{Aspect Name} & \bf{Description} \\
\hline
\hline
\multirow{3}{*}{system} & \blt hw/sw partitioning & capture mapping between  \\
                        & \blt monitorisation & application modules and \\
                        & \blt reconfiguration & GPP/FPGA accelerators\\
\hline
\multirow{2}{*}{implementation} &\blt operator optimisation &  capture low-level hardware \\
& \blt word-length spec & optimisations  \\
\hline
\multirow{3}{*}{exploration} & \multirow{2}{*}{\blt iterative} & generate multiple implemen- \\
 & \multirow{2}{*}{\blt metaheuristic} & tations based on design  \\
 & & space exploration strategies \\
\hline
\multirow{3}{*}{development} & \blt simulation & \multirow{2}{*}{improve developer}  \\
& \blt debugging & \multirow{2}{*}{productivity} \\
& \blt compilation &  \\
\hline
\end{tabular}
\end{table}


\section{System Aspect Descriptions}
{\bf System aspect descriptions} capture transformation
or optimisation strategies that affect the whole application such as
those concerning hardware/software partitioning, monitorisation and
run-time reconfiguration capabilities. The goal of hardware/ software
partitioning is to improve the overall execution time by identifying
parts of the code to be offloaded to hardware
(Section~\ref{sect:asp_hsp}). Monitorisation aspects instrument the
application code to extract run-time behaviour, and uncover
opportunities for optimisation (Section~\ref{sect:asp_mon}).
Run-time reconfiguration can be used to remove idle functions
from the accelerator at specific points in time, so that
additional resources can be dedicated to functions that are
active \cite{Xinyu:Qiwei:Luk:Qiang:Pell:2012}.


\subsection{Hardware/Software Partitioning}
\label{sect:asp_hsp}
\FAST{} functions describing dataflow computations can be embedded
within the C application but, as explained in
\Cref{sec:kernels-streams}, cannot be invoked directly by software C
functions.  Instead, a \FAST{} pragma must is used to indicate the
link between the software function call and the alternate hardware
implementation as shown in Listing  \ref{lst:aspect-switch}. indicates that the software
implementation of \texttt{f()} can be mapped to the dataflow
implementation described in \texttt{fast\_f()}. This way, our
design-flow can automatically switch from a pure software application
to a software/hardware design.

\lstset{style=MaxC}
\begin{lstlisting}{caption={Mapping of C function calls to dataflow kernels using \FAST{} pragmas.}, label={lst:aspect-switch}}
void fast_f()  {/* dataflow implementation */}
void      f()  {/* software implementation */}
int main() {
  #pragma fast hw:fast_f
  f();
}
\end{lstlisting}
\
Hence, a hardware/software partitioning strategy can be performed in
five steps:
\begin{enumerate}
  \item detecting hotspots in the program;
  \item detecting code patterns from hotspots that are suited for
    dataflow computation and acceleration;
  \item performing the outlining transformation so that each
    candidate for acceleration is enclosed in a function \texttt{f};
  \item deriving a dataflow version \texttt{fast\_f} from state-based
    \texttt{f};
  \item placing a FAST pragma on top of each function call to
    \texttt{f} and associate it to the corresponding \texttt{fast\_f}
    function.
\end{enumerate}

Each of these steps can be described as a separate LARA aspect and
combined to form a hardware/software partitioning strategy.



\subsection{Monitorisation}
\label{sect:asp_mon}
To find potential hotspots in the application, we can use the aspect
in Listing \ref{fig:hotspot}.  With this aspect, the weaver can
automatically instrument any C application to self-monitor its
innermost loops at run-time, as they are natural candidates for
dataflow-based acceleration. In particular, this monitorization aspect
can compute the following information for every innermost loop:
\begin{enumerate}
\item the average number of times it has been executed,
\item the average number of iterations,
\item the loop average execution time,
\item the loop iteration average execution time.
\end{enumerate}

For this purpose, we use a simple monitoring API, to record the
frequency of execution and the loop iteration and execution time:.
\begin{itemize}
\item \texttt{monitor\_instanceI} and \texttt{monitor\_instanceE} -- mark
  the beginning and end of the loop respectively;
\item \texttt{monitor\_iterI} and \texttt{monitor\_iterE} -- mark the
  beginning and end of an iteration respectively.
\end{itemize}

\lstset{style=lara}
\begin{lstlisting}[caption={Aspect that instruments the application to monitor loop
  activity. The information generated can be used to identify
  hotspots.}, label={lst:hotspot}]
aspectdef LoopMonitor
select function.loop{is_innermost} end
apply
    $loop.insert before
       %{monitor_instanceI("[[$loop.key]]");}%;
    $loop.insert after
       %{monitor_instanceE("[[$loop.key]]");}%;
end

select function.loop{is_innermost}.entry end
apply $begin.insert after
       %{monitor_iterI("[[$loop.key]]");}%;
end
select function.loop{is_innermost}.exit end
apply $begin.insert before
       %{monitor_iterE("[[$loop.key]]");}%;
end
end
\end{lstlisting}

The aspect code is shown in Listing~\ref{lst:hotspot}. Lines~2--8 select
all innermost loop instances and place an instance monitor call before
and after each selected loop. Lines~10--13 select all entry points
inside the loop and insert a monitoring call to mark the beginning of
each iteration. Lines~14--17 place an instance monitor call to mark
the end of each iteration. The following table shows an example of
applying the aspect from Listing~\ref{lst:hotspot} on a C-style function
containing a loop:

{\footnotesize
\fontfamily{pcr}\selectfont
\begin{center}
\begin{tabular}{l|l}
\hline
\bf{original code}           & \bf{woven code}                                   \\
\hline
\hline
void f() \{                  & void f() \{                                       \\
%\hspace{3ex}$\ldots$        & \hspace{3ex}$\ldots$                              \\
                             & \hspace{3ex}\marktext{monitor\_instanceI("f:1");} \\
\hspace{3ex}while (i < N) \{ & \hspace{3ex}while (i < N) \{                      \\
                             & \hspace{6ex}\marktext{monitor\_iterI("f:1");}     \\
\hspace{6ex}i++;             & \hspace{6ex}i++;                                  \\
                             & \hspace{6ex}\marktext{monitor\_iterE("f:1");}     \\
\hspace{3ex}\}               & \hspace{3ex}\}                                    \\
                             & \hspace{3ex}\marktext{monitor\_instanceE("f:1");} \\
\}                           & \}                                                \\
%\hspace{3ex}$\ldots$        & \hspace{3ex}$\ldots$                              \\
\hline
\end{tabular}
\end{center}
}

Each monitoring call in the woven code receives as a parameter a
unique loop key which identifies the loop within the application. The
loop key is generated by concatenating the function name with the
hierarchical position of the loop within the abstract syntax tree. For
instance, \emph{f:2:1} corresponds to the 1st loop inside the 2nd
outermost loop of function \texttt{f}. The hotspots can be identified
by an aspect (not shown) that takes the profiling information
generated by the monitorization API calls, and that uses an heuristic
to compute the most profitable computations to be offloaded to
hardware.

\subsection{Modelling}

A prerequisite of developing more advanced aspects is the ability to
effectively model resource usage. In practice, an approximate resource
usage and performance model is developed by application engineers,
prior to the design optimisation process. Presently, this is done
manually, or can be automated but not at a high enough level
abstraction (e.g. C programming level). An automatically derived
resource model improve developer productivity by providing design
information earlier in the development process, albeit just an
estimates.

Modelling aspect descriptions can be used to generate design models
for FAST dataflow designs.  For example, the aspect description of
Listing \ref{lst:asp-modelling} can be used to estimate resource usage
of arithmetic operations. It relies on the existence of an operation
resource usage map (opUsageMap) that contains an estimate of the per
operation resource usage. This estimate can be refined via analysis of
backend tool reports, using the feedback capabilities of the LARA
design space exploration flow. Based on this estimate the aspect
updates the current designModel with estimates of total resource usage
for each loop loop statement

\begin{lstlisting}[
  style=lara,
  caption={Aspect for modelling resource usage of arithmetic operations.},
  label={lst:asp-modelling}
]
aspectdef usageLUT
input
  opUsageMap, designModel
end
  var totalUsageLUT = 0;
select function.statement
apply
  for(var op in {+, -, *, /})
    nOpps = statement.num_construct[op]
    usageLUT = opUsageMap[op].LUT * nadds * loop max iteration
    switch (loop.balanceDSP) {
      FULL: usageLUT = 0
      BALANCED: usageLUT *= 0.5
      NONE: usageLUT *= 1
    }
    desginModel.block[loop].resource.LUT = usageLUT
    totalUsageLUT += usageLUT
    designModel.resource.LUT= totalUsageLUT
  end
end
\end{lstlisting}


To model design performance we can, for example, use the aspect of
Listing \ref{lst:asp-pipedepth} to estimate the pipeline depth, based
on which design latency can be estimated as $\text{depth} *
\text{design clock frequency}$. This operates similarly to the
previous aspect, by expecting as input an operator pipeline depth and
then estimating the pipeline depth of loop constructs.

\begin{lstlisting}[
  style=lara,
  caption={Aspect for modelling pipeline depth of arithmetic kernels.},
  label={lst:asp-pipedepth}
]
aspectdef pipelineDepth
input
  opPipelineMap, designModel
end
var designDepth = 0;
select function.loop{is_innermost}
apply
  loopDepth = tree_depth(loop_body, opPipelineMap) * loop.pipelineFactor
  designDepth += loopDepth
  designModel.block[loop].performance.pipeDepth = loopDepth
  designModel.performance.pipeDepth = designDepth
  designModel.performance.pipeDepth = designDepth
end
\end{lstlisting}

These aspects are called by a higher level aspect that is intended as
the primary means for users to interact and parametrize the lower
level aspects. This hierarchical approach ensures a gradual
abstraction of details, which simplifies the development process.  The
aspect of Listing \ref{lst:asp-modhigh} provides a single entry point
for the modelling flow, where the operator can maintain a list of
platform level properties. Such portable descriptions already exist
for more widely used FPGA based systems, requiring just a simple
translation step to fully automate the modelling process.

\begin{lstlisting}[
  style=lara,
  caption={Higher-level aspect for modelling design resource usage.},
  label={lst:asp-modhigh}
]
aspectdef designModel
input
opPipelineMap
opUsageMap
end
for (var design in DesignDatabse)
  call usageLUT(opUsageMap, design)
  call pipelineDepth(opPipelineMap, design)
end
\end{lstlisting}

\subsection{Run-time Reconfiguration}
\label{sect:asp_reconfig}


Run-time reconfiguration aspects are used to partition and generate
hardware/software links required for reconfiguration based on user
specified requirements and optimisation goals.

To support run-time reconfiguration, we specify the configuration
associated with the function call in the \FAST{} pragma. For instance:

\noindent\texttt{\footnotesize{\marktext{\#pragma FAST hw:fast\_f0 cfg:c0}\\
x = f(0); \\
\marktext{\#pragma FAST hw:fast\_f1 cfg:c1}\\
y = f(x); \\
\marktext{\#pragma FAST hw:fast\_g cfg:c1}\\
z = g(x); \\
}}

\noindent With the above code annotations, our design-flow can
generate multiple configurations, each containing a set of \FAST{}
implementations that can be executed in parallel. If the configuration
name is not specified using the \FAST{} pragma, then we assume a
default configuration. Having a single configuration can lead to
situations where at any point in time and due to data dependencies,
part of the functions are idle. With run-time reconfiguration, we can
exploit unused resources to support active functions. In particular,
during the execution of an application, we select various
configurations at different points in time to maximise the utilisation
of FPGA resources. Within this context, we use a hardware partition,
which contains a set of configurations that are used to support
reconfiguration during the life cycle of an application. In the above
example, configuration \texttt{c0} contains a single implementation of
\texttt{f} (\texttt{fast\_f0}), and thus can potentially use more
resources and be faster than the \texttt{fast\_f1} version which must
share the same configuration (\texttt{c1}) with \texttt{fast\_g}.

The work in~\cite{Xinyu:Qiwei:Luk:Qiang:Pell:2012} proposes an
approach for extracting valid and efficient hardware partitions. To realize
run-time reconfiguration without modifying the original code we use the
aspect shown in Fig.~\ref{fig:aspect-reconf}.  The input to the
aspect is a hardware partition (lines 2--4). The partition is implemented as a
hash table that maps a function call (key) to a hardware
implementation, represented as a tuple containing the hardware
implementation name (hw) and the associated configuration (cfg).

\lstset{style=lara}
\begin{figure}[!h]
\begin{lstlisting}
aspectdef AspReconfig
input
   partition
end
select function.call end
apply
   if ($call.key in partition) {
      var cfg = partition[$call.key].cfg;
      var hw = partition[$call.key].hw;
      $call.insert before %{
         #pragma FAST hw:[[hw]] cfg:[[cfg]]
      }%;
   }
end
end
\end{lstlisting}
\caption{Reconfiguration aspect.}
\label{fig:aspect-reconf}
\end{figure}

Table \ref{fig:aspect-hash} shows an example of a hash table
representing a hardware partition. The key (e.g. main:f:1) identifies
a function call in the application, and is formed by concatenating the
name of the caller function (main), the name of the invoked function
(e.g. f) and a unique number (1).  Line~5 in the aspect shown in
Fig.~\ref{fig:aspect-reconf} selects all function calls, and for each
call found in the input partition (line~7), we set the appropriate
pragma on top of the call statement (lines 10--12). We can now realize
and experiment different reconfiguration designs by invoking this
aspect with different hardware partitions.


%{\footnotesize
%\fontfamily{pcr}\selectfont
\begin{table}[!h]
\caption{An example of a hardware partition, represented as a hash
  table, used with the reconfiguration aspect
  (Fig.~\ref{fig:aspect-reconf})}
\label{fig:aspect-hash}
\centering
\begin{tabular}{c|c|c}
\hline
\multicolumn{3}{c}{\bf{partition}} \\
\hline
\bf{\$call.key} & \bf{hw} & \bf{cfg}  \\
\hline
main:f:1 & fast\_f0 & c0 \\
main:f:2 & fast\_f1 & c1 \\
main:g:3 & fast\_g & c1 \\
\hline
\end{tabular}
\end{table}
\begin{comment}
\subsection{Feedback Aspects}
Used to complement predicted model data (such as resource usage) from
back-end compilation reports or execution of automated performance
test suites. This improves estimates (e.g. for reconfiguration cost /
performance improvement etc.)
\end{comment}

\section{Implementation Aspect Descriptions}

Implementation aspects focus on
low level design optimisations that can be applied to designs in
\FAST{} to improve timing or resource usage. For instance, operator
optimisation aspects (Section~\ref{sect:asp_ops}) can be used to map
operators in the program to dedicated hardware resources. Word-length
aspects specify the numerical representation of variables and
expressions in the design.




\subsection{Operator Optimisation}
\label{sect:asp_ops}
To provide architectural details to \FAST{} designs, such as mapping
operators to DSP blocks, we can use the \FAST{} pragma shown in
Fig. \ref{fig:aspect-balance} at the top of a statement (including code
blocks). The balancing parameter corresponds to the degree of
utilisation of DSP blocks in a statement.

\lstset{style=MaxC}
\begin{figure}[!h]
\begin{lstlisting}
(*@ \marktext{\#pragma FAST balanceDSP:balanced} @*)
{
  x = x * y;
  x++;
}
\end{lstlisting}
\caption{The \FAST{} balancing pragma provides fine grained control
  over the mapping of computation to either DSPs or LUT/FF pairs.}
\label{fig:aspect-balance}
\end{figure}

The aspect shown in Fig.~\ref{fig:aspect-DSP} is the strategy for
balancing DSP blocks in every statement of an application. Instead of
adding the above pragma manually, we provide a set of rules
(lines~3--4) that define where to place the \texttt{balanceDSP}
pragma. In this example, we established the rule that full DSP block
utilisation is applied to any statement that has 5 or more
multipliers and adders, balanced if 3 or more multipliers, and no DSP
utilisation otherwise.

\lstset{style=lara}
\begin{figure}[!h]
  \centering
  \begin{lstlisting}
aspectdef DspBalancing
var op_granularity =
 [{DspBalance:'full',MultiplyOp: 5,AddOp: 5 },
  {DspBalance:'balanced',MultiplyOp:3}];

select function.statement end
apply
   for (var i in op_granularity) {
      var gprofile = op_granularity[i];
      var match = true;
      for (var k in gprofile) {
         if (k != 'DspBalance') {
            match &= ($statement.num_construct(k)
                      >= gprofile[k]);}}
      if (match) {
         var pragma = '#pragma FAST balanceDSP:'
                      + gprofile.DspFactor;
         $statement.insert before "[[pragma]]";
         break;}}
   end
end
  \end{lstlisting}
  \caption{Aspect for exploring mapping of computation to DSP blocks.}
  \label{fig:aspect-DSP}
\end{figure}




\section{Exploration Aspect Descriptions}

Exploration aspects deal with strategies that generate multiple designs to find an optimal
implementation based on user requirements. Exploration aspects can act
on any level of the design flow (C code, C and \FAST{}, or \FAST{}
functions). They enable systematic exploration of trade-offs and
optimisation opportunities. Examples of exploration aspects include
iterative aspects (Section~\ref{sect:asp_it}) which generate a
sequence of solutions until a termination criterion is satisfied, and
metaheuristic-based aspects to find optimal solutions in a very large
design space.

\subsection{Iterative Design Space Exploration}
\label{sect:asp_it}
Using LARA we can implement and combine these aspects to enable
systematic design space exploration of all the optimisation options
exposed by the \FAST{} backend resulting in the generation of a large
number of designs. The feedback-directed compilation process of LARA
can be used to capture and extract feedback from the backend reports
pertaining to resource usage or timing information and automatically
adjust the compilation process.

An example of a LARA aspect for design space exploration is
shown in Fig.~\ref{fig:aspect-exploration}. It highlights the feedback capabilities of the design
flow: the aspect will generate and build the \FAST{} designs until the
resource usage passes a specified LUT threshold, and at each step
increasing a particular design attribute, such as exponent, mantissa or the parallelism of the design (by replicating the computational pipeline).

\lstset{style=lara}
\begin{figure}[!h]
\begin{lstlisting}
  aspectdef DesignExploration
  input
     attribute,
     start, step,
     lut_threshold,
     config
  end
  config[attribute] = start;
  var i = 0;
  do {
    var designName = genName(config);
    call genFAST(designName, config);
    buildFAST(designName);
    config[attribute] += step; i++;
  } while (@hw[designName].lut < lut_threshold
           && i < LIMIT);
  end
\end{lstlisting}
\caption{Exploration aspect that generates multiple \FAST{} designs by varying a design attribute (e.g. number of kernels or mantissa) until a LUT threshold is reached.}
\label{fig:aspect-exploration}
\end{figure}


\section{Development Aspect Descriptions}

Development aspects capture transformations that have an impact on the
development process such as debugging (Section~\ref{sect:asp_debug}),
and, potentially, simulating kernels or improving compilation
speed. Separating these concerns makes the original code easier to
maintain and enables the automatic application of these
transformations to a wide range of designs, improving developer
productivity. Simulation aspects could be applied to dataflow designs
to generate equivalent state-based C code thus enabling pure software
simulation. Compilation aspects, on the other hand, could be applied
during the development process to create versions of the dataflow
design that compile faster by reducing the operating frequency,
removing debug blocks or applying design-level optimisations that can
resolve timing constraints. Naturally, reducing the compilation time
would increase developer productivity.












\subsection{Debugging Aspect}
\label{sect:asp_debug}
Because the current execution model does not provide run-time debugging
of hardware designs, the easiest solution to debug designs is to log
the values of various streams during execution. The insertion of debug
statements can be encapsulated in aspects. It is particularly
important to separate debug aspects from the original application code
since debug blocks can influence the compilation time and timing
constraints as well as the behaviour of the design. As an example,
the aspect in Fig. ~\ref{fig:aspect-debug} instruments the code to log every change in the value of a variable.

\lstset{style=lara}
\begin{figure}[!h]
  \centering
\begin{lstlisting}
aspectdef WatchVar
select function.vref end
apply
   $vref.parent_stmt.insert before
    %{ log("[[$vref.name]]", [[$vref.name]]); }%
   $vref.parent_stmt.insert after
    %{ log("[[$vref.name]]", [[$vref.name]]); }%
end
condition $vref.is_out end
end
\end{lstlisting}
  \caption{Aspect for automatically instrumenting the code to watch any change in the value of a program variable.}
  \label{fig:aspect-debug}
\end{figure}


\section{Summary}

We have introduced the four main classes of novel aspect descriptions
used with our the proposed design flow. System aspect descriptions
operate at the whole system level (C + \FAST{} specification) to
generate hardware/software partitioning, run-time reconfiguration
designs, monitorisation and modelling of resource usage and
performance data.  Implementation aspect descriptions operate at the
design level and perform low level optimisations such as mapping of
computation to DSPs or adjusting word length. Exploration aspect
descriptions are used to drive the design space exploration process,
for example, iteratively increase a certain design property (such as
parallelism or clock frequency) until a certain requirement is met
(e.g. resource usage threshold is exceeded or execution time
requirement is met). Finally, development aspect descriptions can be
used to capture strategies that are related to the development
process, such as the need for monitoring values or reducing
compilation time.
