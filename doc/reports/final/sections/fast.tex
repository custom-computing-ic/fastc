\chapter{The \FAST{} Language}
\label{sec:fast}

\FAST{} (Facile Aspect-driven Source Transformation) is a novel
language for specifying dataflow designs that are used as a starting
point for the design flow proposed in Section
\ref{sec:design-flow}. In particular, we use C syntax to capture
dataflow computations, and, instead of heavily relying on API libraries
to specify the design (as in MaxCompiler \cite{5719584} or Streams-C
\cite{Gokhale:Stone:Arnold:Kalinowski:2000}), we use aspects to
implement the transformations required for the actual implementation.

\section{Design Goals}

\FAST{} provides the following features that are
required by the proposed flow:

\begin{itemize}
\item \emph{Imperative specification of dataflow designs}. C99 syntax
  is enforced by the \FAST{} compiler which is based on the ROSE
  Framework~\cite{Quinlan:2000}. The familiar syntax makes the
  language easy to adopt thus facilitating translation of existing
  implementations to dataflow designs.
\item \emph{Good integration with existing source level translation and
    weaving tools}. Simple syntax allows the language to interact well
  with existing compilers or source to source translation frameworks,
  allowing source level optimisations to be applied through different
  tools.
\item \emph{Combined hardware/software design}. Specifications of dataflow
  kernels and CPU run-time software can be mixed. The example shown in
  Fig.~\ref{fig:maxc-1dconv} can be compiled with the GCC toolchain,
  but when using the \FAST{} compiler, the pragma indicates the link
  between the software and hardware, which results in an accelerated
  hardware/software solution.
\item \emph{Support for data path and control path generation}. \FAST{}
  allows specifying both data and control operations that are
  automatically mapped to stream multiplexers.
\end{itemize}

\FAST{} is used to express the simplest form of a dataflow design
while optimisations and other transformations are encapsulated in
aspects which are developed separately and applied through aspect
weaving. This results in a flexible approach for generating and
exploring the space of efficient dataflow designs.

Designs in \FAST{} are compiled to MaxCompiler designs composed of
inter-connected functional kernels. Communication between kernels is
asynchronous, so they can operate independently, and compute only when
all active inputs have available data.

\section{Features}

Table~\ref{table:maxc-features} summarises the features of \FAST{} and
Fig.~\ref{fig:maxc-1dconv} shows an example dataflow kernel used to
value European options. Kernels are defined as regular C functions
with inputs clearly defined as arguments in the function
signature. Streams are represented as regular C99-style pointers.
Normal array notation can be used to generate either previous or
future values or dereference the stream to obtain the current stream
value. Negative indices are allowed for accessing previous stream
values and supported offset expressions are linear expressions
comprised of constants or variables (either loop induction variables,
or normal variables but for which a compile time range of values is
specified, as a requirement for generating efficient
hardware). Constructs such as loops are supported as long as their
bounds are known at compilation time and are used to parametrise
dataflow designs.

\begin{table}[!h]
  \centering
  \renewcommand{\arraystretch}{1.5}
  \caption{Summary of the main features of the \FAST{} language.}
  \label{table:maxc-features}
  \begin{tabularx}{\textwidth}{X|X|X}
    \hline
    \bf{Feature}                   & \bf{Description}                   & \bf{Method (see Fig.~\ref{fig:maxc-1dconv})} \\
    \hline\hline
    \multirow{2}{*}{Input/Output}         & Declared in function header          & C99 (line 1)                                 \\\cline{2-3}       & \texttt{in()},\texttt{out()}  & \FAST{} API (lines 2,11) \\
    \hline
    \multirow{2}{*}{Control}     & Ternary op., \texttt{if} statement & C99 (line 11)                                \\\cline{2-3}      & Stream mux (\texttt{mux()})       & \FAST{} API  \\
    \hline
    \multirow{2}{*}{Computation} & +, *, /, -                         & C99 (line 8)                           \\\cline{2-3} & log, exp, sqrt, sin etc.  & \#include $<$math.h$>$  \\
    \hline
    \multirow{2}{*}{Streams}     & Declared as pointers               & C99 (line 1)                                 \\\cline{2-3}       & Accessed with array index & C99 (line 8) \\
    \hline
    Optimisation                 & C pragmas                   & C99 (line 7)                                 \\
    \hline
    Parameterization             & Constants, variables                   & C99                                          \\
    \hline
    Hardware \  Mapping                  & C pragmas                   & C99 (line 17)                                \\
  \end{tabularx}
\end{table}


\lstset{style=MaxC}

\begin{lstlisting}[caption={\FAST{} dataflow kernel for European Options pricing}]
  void Price_FPGA(
  float* p,
  float c_0_0_0, float c_p_0_0, float c_n_0_0,
  int n1, int ORDER)
  {
    in(p);

    float* i4 = count(1000, 1);
    float* i1 = countChain(n1, 1, i4);

    #pragma FAST DSPBalance:full
    int result =
    p[0]  * c_0_0_0 +
    p[1]  * c_p_0_0 +
    p[-1] * c_n_0_0;

    int up =(i1 >= ORDER) && (i1 < n1 - ORDER);
    out(up ? result : p);
  }

  void Price_CPU(...) {...}

  int main() {
    #pragma FAST hw:Price_FPGA
    Price_CPU(...);
  }
\end{lstlisting}


The \FAST{} API provides higher-level constructs such as I/O functions
(\texttt{in()}, \texttt{out()}), counters (Fig.~\ref{fig:maxc-1dconv},
Lines~4--5) and functions to multiplex streams (\texttt{mux()}). C
function calls are mapped to dataflow kernels via pragmas (Line 17)
which provides the flexibility of selecting a particular dataflow
configuration based on run-time conditions. Support for run-time
reconfiguration is included but will be described in a future
publication due to lack of space.

\subsection{Kernels}

Kernels represent a unit of computation that is mapped to the FPGA.
They are C functions that can be used directly (as below) or linked
via pragmas in C application code.

\begin{lstlisting}[caption={Simple \FAST{} dataflow kernel.}]
  // standard C main function
  int main() {
    int *x = ..., *y = ...;
    PassThrough(x, y);
    ...
  }

  #pragma maxc dataflow(y)
  void PassThrough(int *x, int *y) {
    *y =  x;
  }
\end{lstlisting}

\subsection{Streams}
The example above shows a very simple kernels with two streams:

\begin{itemize}
\item output (write) stream "y" - allows access to previous and current values;
\item input (read) stream "x" - allows access to previous, current and future values;
\end{itemize}

The kernel Sum shown below computes the sum of input stream
x. CURRENT\_CYCLE is a special value defined by MaxC that holds the
value of the current kernel cycle.

\begin{lstlisting}[caption={\FAST{} kernel computing the sum of an input stream.}]
  #pragma maxc dataflow(y)
  void Sum(int *x, int *y) {
    if ( CURRENT_CYCLE == 0 )
    *y = x[0];
    else
    *y = y[-1] + x[0];
  }
\end{lstlisting}

All streams declared within a kernel are write streams.

The indices for stream offsets can be compile time values as in the
example above. When using run-time values, it can be more efficient
(in terms of FPGA resource utilization) to specify bounds for the
offset expressions. For example in the kernel shown below, the input
stream "offests" contains offsets at which to select elements from
input stream "x". We may, for example, know that our application is
only expect to use offsets smaller than 256, so we can provide this
optimization hint to the compiler.

\begin{lstlisting}[caption={\FAST{} kernel using offsets.}]
  void Bounds(int *x, int *offsets, int *y) {
    int bounded_offset = make_offset(*offsets, 0, 256);
    *y = x[*offsets] * 2;
  }
\end{lstlisting}

\subsection{Inputs and Outputs}

In the examples above we declare inputs and outputs in the kernel
headers. Assigning to a declared output stream automatically outputs
the value. Assignments to input streams are illegal and an error is
indicated by the compiler.

\subsection{Control}

\subsubsection*{Conditionals}

Regular control statements can be used. When conditionals are based on
stream values, the control statement maps to hardware multiplexers
(e.g. in the Sum kernel above, if ( CURRENT\_CYCLE == 0 )).

\subsubsection*{Loops}

It is only possible to use loops statements (while, for) if their
bounds and induction variables are known at compile time. In the
ParallelSum kernel below the loop is used to replicate the computation
Par times.

\begin{lstlisting}[caption={Using loops for \FAST{} design parametrisation}]
  void ParallelSum(int *x[Par], int *Sum[Par]) {
    for (int i=0; i <Par; i++)
    sum[i][0] = sum[i-1][0] + x[i][0];
  }
\end{lstlisting}
\subsection{Computation}

\begin{itemize}

\item C arithmetic operators can be used as usual on stream values (not streams themselves).
\item Arithmetic on streams (equiv. to pointer arithmetic) is illegal.
\item C math.h function calls are automatically mapped to efficient hardware blocks.

\end{itemize}

The example below computes the difference between the arithmetic and geometric average of two consecutive elements in a streams (boundary cases ignored).


\begin{lstlisting}
  void AvgDiff(int *x, int *y) {
    int arithmetic_avg = (x[0] + x[-1]) / 2;
    int geometric_avg  = (sqrt(x[0] * x[-1]);
    *y = geom - avg;
  }
\end{lstlisting}

\subsection{State}
State can be saved and subsequently accessed between kernel iterations
by use of global values as shown in the kernel CycleSum that adds the
current cycle count to the value of the input stream, and also updates
the cycle value before the next iteration
\begin{lstlisting}
  int cycle = 0;
  void CycleSum(int *x, int *y) {
    *y = *x + cycle;
    cycle++;
  }
\end{lstlisting}
\section{Extensions}

\subsection{Inferring Stream Type}
\subsection{LMem Support}
\subsection{Multiple Kernel Support}
\subsection{Run-time Reconfiguration Support}

\section{Summary}
